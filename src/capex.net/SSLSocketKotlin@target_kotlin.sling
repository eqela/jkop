
/*
 * This file is part of Jkop
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class is SSLSocket:

prop ctx as LoggingContext
prop socket as TCPSocket
prop serverAddress as string
var acceptInvalidCertificate as bool
var requireClientCertificate = false
var blocking as bool = true

var sslSocket as !"javax.net.ssl.SSLSocket"
var jvcSocket as !"java.net.Socket"
var sslEngine as !"javax.net.ssl.SSLEngine" 

var myAppData as !"java.nio.ByteBuffer"
var myNetData as !"java.nio.ByteBuffer"
var peerAppData as !"java.nio.ByteBuffer"
var peerNetData as !"java.nio.ByteBuffer"

func setAcceptInvalidCertificate(v as bool) override:
	acceptInvalidCertificate = v

func setRequireClientCertificate(v as bool) override:
	requireClientCertificate = v

func open(cSocket as ConnectedSocket, certFile as File = null, keyFile as File = null, isServer as bool = false, passphrase as string = null) as bool
{
	var v = true
	socket = cSocket as TCPSocket
	var address = serverAddress
	if String.isEmpty(address):
		address = socket.getRemoteAddress()
	assert String.isNotEmpty(address)
	var port = socket.getRemotePort()
	jvcSocket = (socket as! TCPSocketForKotlin).getJavaClientSocket()
	lang "kotlin" {{{
		try {
			var trustAllCerts = kotlin.arrayOf(object : javax.net.ssl.X509TrustManager {
				override fun getAcceptedIssuers() : kotlin.Array<java.security.cert.X509Certificate> {
					return kotlin.emptyArray<java.security.cert.X509Certificate>()
				}
				override fun checkClientTrusted(certs : kotlin.Array<java.security.cert.X509Certificate>, authType : kotlin.String) {
				}
				override fun checkServerTrusted(certs : kotlin.Array<java.security.cert.X509Certificate>, authType : kotlin.String) {
				}
			})
			var sslContext = javax.net.ssl.SSLContext.getInstance("TLSv1.2")
			if (isServer) {
				var file = java.io.FileInputStream(certFile!!.getPath())
				var keyStore = java.security.KeyStore.getInstance("JKS")
				keyStore.load(file, passphrase!!.toCharArray())

				var keyManagerFactory = javax.net.ssl.KeyManagerFactory.getInstance("SunX509")
				keyManagerFactory.init(keyStore, passphrase!!.toCharArray())
				
				var trustManagerFactory = javax.net.ssl.TrustManagerFactory.getInstance(javax.net.ssl.TrustManagerFactory.getDefaultAlgorithm())
				trustManagerFactory.init(keyStore)
				if (acceptInvalidCertificate) {
					sslContext.init(keyManagerFactory.getKeyManagers(), trustAllCerts, java.security.SecureRandom())
				}
				else {
					sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), java.security.SecureRandom())
				}
			}
			else {
				sslContext.init(null, trustAllCerts, java.security.SecureRandom())
			}
			sslEngine = sslContext.createSSLEngine()
			kotlin.io.println("Supported protocol")
			for (pr in sslEngine!!.getSupportedProtocols()) {
				kotlin.io.println("\tS PROTOCOL : " + pr)
			}
			kotlin.io.println("Enabled protocol")
			for (pr in sslEngine!!.getEnabledProtocols()) {
				kotlin.io.println("\tPROTOCOL : " + pr)
			}
			sslEngine?.getSession()?.invalidate()
			sslEngine?.setEnabledProtocols(kotlin.arrayOf<kotlin.String>("TLSv1.2"))
			if (isServer) {
				sslEngine?.setWantClientAuth(requireClientCertificate)
			}
			kotlin.io.println("CLIENT MODE = " + !isServer)
			sslEngine?.setUseClientMode(!isServer)
			sslEngine?.beginHandshake()
			handleHandshake()
		}
		catch(e : kotlin.Exception) {
			e.printStackTrace()
			v = false
		}
	}}}
	return v
}

func handleHandshake
{

	var asize as int = sslEngine.getSession().getApplicationBufferSize()
	var psize as int = sslEngine.getSession().getPacketBufferSize()
	PRINT "APPLICATION BUFFER SIZE = " .. String.asString(asize)
	PRINT "PACKET BUFFER SIZE = " .. String.asString(psize)
	PRINT "\n\nHandling handshake..."
	var mdsrc = lang "kotlin" !"java.nio.ByteBuffer" {{{ java.nio.ByteBuffer.allocate(asize) }}}
	var mndst = lang "kotlin" !"java.nio.ByteBuffer" {{{ java.nio.ByteBuffer.allocate(psize) }}}
	var pdsrc = lang "kotlin" !"java.nio.ByteBuffer" {{{ java.nio.ByteBuffer.allocate(asize) }}}
	var pndst = lang "kotlin" !"java.nio.ByteBuffer" {{{ java.nio.ByteBuffer.allocate(psize) }}}
	var executor = lang "kotlin" !"java.util.concurrent.ExecutorService" {{{ java.util.concurrent.Executors.newSingleThreadExecutor() }}}
	var result as !"javax.net.ssl.SSLEngineResult"
	var status as !"javax.net.ssl.SSLEngineResult.HandshakeStatus" = sslEngine.getHandshakeStatus()
	lang "kotlin" {{{
		while (status != javax.net.ssl.SSLEngineResult.HandshakeStatus.FINISHED && status != javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
			kotlin.io.println("[STATUS] : " + status)
			switch@ when (status) {
				javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_UNWRAP -> {
					if (readJvcSocket(pndst) < 0) {
						if (sslEngine!!.isInboundDone() && sslEngine!!.isOutboundDone()) {
							return
						}
						try {
							sslEngine!!.closeInbound()
						}
						catch (e : kotlin.Exception) {
							kotlin.io.println("\tFailed closing inbound")
						}
						sslEngine!!.closeOutbound()
						kotlin.io.println("\tFailed in NEED_UNWRAP")
						return@switch
					}
					pndst!!.flip()
					try {
						result = sslEngine!!.unwrap(pndst, pdsrc)
						pndst!!.compact()
						status = result!!.getHandshakeStatus()
					}
					catch (e : kotlin.Exception) {
						//close
						kotlin.io.println("\tFailed in NEED_UNWRAP 1")
						e.printStackTrace()
						sslEngine!!.closeOutbound()
						status = sslEngine!!.getHandshakeStatus()
						return@switch
					}
					when (result!!.getStatus()) {
						javax.net.ssl.SSLEngineResult.Status.OK -> {
							kotlin.io.println("\tOK on NEED_UNWRAP ")
						}
						javax.net.ssl.SSLEngineResult.Status.BUFFER_OVERFLOW -> {
							kotlin.io.println("\tFailed in NEED_UNWRAP 2 : BUFFER_OVERFLOW")
							pdsrc = java.nio.ByteBuffer.allocate(sslEngine!!.getSession()?.getApplicationBufferSize()!!)
						}
						javax.net.ssl.SSLEngineResult.Status.BUFFER_UNDERFLOW -> {
							kotlin.io.println("\tFailed in NEED_UNWRAP 3 : BUFFER_UNDERFLOW")
						}
						javax.net.ssl.SSLEngineResult.Status.CLOSED -> {
							// close
							kotlin.io.println("\tFailed in NEED_UNWRAP 4 : CLOSED")
							status = sslEngine!!.getHandshakeStatus()
						}
					}
				}
				javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_WRAP -> {
					mndst!!.clear()
					try {
						result = sslEngine!!.wrap(mdsrc, mndst)
						status = result!!.getHandshakeStatus()
					}
					catch (e : kotlin.Exception) {
						kotlin.io.println("\tFailed in NEED_WRAP")
						status = sslEngine!!.getHandshakeStatus()
						return@switch
					}
					when (result!!.getStatus()) {
						javax.net.ssl.SSLEngineResult.Status.OK -> {
							mndst!!.flip()
							while (mndst!!.hasRemaining()) {
								writeJvcSocket(mndst)
							}
							kotlin.io.println("\tOK on NEED_WRAP ")
						}
						javax.net.ssl.SSLEngineResult.Status.BUFFER_OVERFLOW -> {
							kotlin.io.println("\tFailed in NEED_WRAP 2 : BUFFER_OVERFLOW")
						}
						javax.net.ssl.SSLEngineResult.Status.BUFFER_UNDERFLOW -> {
							kotlin.io.println("\tFailed in NEED_WRAP 3 : BUFFER_UNDERFLOW")
						}
						javax.net.ssl.SSLEngineResult.Status.CLOSED -> {
							// close
							status = sslEngine!!.getHandshakeStatus()
						}
					}
				}
				javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_TASK -> {
					while (true) {
						var task = sslEngine!!.getDelegatedTask()
						if (task == null) {
							break
						}
						task.run()
						// java.lang.Thread(task).start()
					}
					status = sslEngine!!.getHandshakeStatus()
				}
				javax.net.ssl.SSLEngineResult.HandshakeStatus.FINISHED -> kotlin.io.println("\tHANDSHAKE STATUS is FINISHED")
				javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING -> kotlin.io.println("\tHANDSHAKE STATUS is NOT_HANDSHAKING")
				else -> kotlin.io.println("\tUNKNOWN STATUS " + status)
			}
		}
		if (status == javax.net.ssl.SSLEngineResult.HandshakeStatus.FINISHED || status == javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
			kotlin.io.println("\n\n***** HANDSHAKE COMPLETE : " + status + " *****\n\n")
		}
	}}}
}

func readJvcSocket(buff as !"java.nio.ByteBuffer") private as int
{
	assert jvcSocket
	var channel = jvcSocket.getChannel()
	var v = 0
	try {
		if channel {
			PRINT "\t\tSTART READING USING CHANNEL"
			v = channel.read(buff)
			PRINT "\t\tFINISH READING USING CHANNEL"
		}
		else {
			PRINT "\t\tSTART READING USING INPUT STREAM"
			var ins = jvcSocket.getInputStream()
			if(blocking == false && ins.available() < 1) {
				return 0
			}
			else {
				var b = buff.array()
				v = ins.read(b)
			}
			PRINT "\t\tFINISH READING USING INPUT STREAM"
		}
	}
	catch e as exception {
		lang "kotlin" {{{
			e.printStackTrace()
		}}}
	}
	return v
}

func writeJvcSocket(buff as !"java.nio.ByteBuffer") private
{
	assert jvcSocket
	var channel = jvcSocket.getChannel()
	try {
		if channel {
			PRINT "\t\tSTART WRINTING USING CHANNEL"
			channel.write(buff)
			PRINT "\t\tFINISH WRINTING USING CHANNEL"
		}
		else {
			PRINT "\t\tSTART WRINTING INPUTSTREAM"
			var os = jvcSocket.getOutputStream()
			os.write(buff.array())
			os.flush()
			PRINT "\t\tFINISH WRINTING INPUTSTREAM"
		}
	}
	catch e as exception {
		lang "kotlin" {{{
			e.printStackTrace()
		}}}
	}
}

func read(buffer as buffer) override as int:
	return readWithTimeout(buffer, -1)

func close override
{
	lang "kotlin" {{{
		try {
			if(sslSocket != null) {
				sslSocket?.close()
				sslSocket = null
			}
		}
		catch(e : kotlin.Exception) {
			e.printStackTrace()
		}
	}}}
	if socket != null {
		socket.close()
		socket = null
	}
}

func readWithTimeout(buffer as buffer, timeout as int) override as int
{
	assert sslSocket
	if not buffer:
		return -1
	var v = 0
	var channel = sslSocket.getChannel()
	if channel {
		PRINT "READ : CHANNEL FOUND"
		lang "kotlin" {{{
			try {
				var ba = buffer!!.toByteArray()
				v = channel!!.read(java.nio.ByteBuffer.wrap(ba))
				var uba = ba.toUByteArray()
				uba.copyInto(buffer)
				kotlin.io.println("READ : CHANNEL DONE WITH " + v)
			}
			catch(e: kotlin.Exception) {
				e.printStackTrace()
				v = -1
				kotlin.io.println("READ : CHANNEL FAILED")
			}
		}}}
	}
	else {
		lang "kotlin" {{{
			try {
				var ins = sslSocket!!.getInputStream();
				if(blocking == false && ins.available() < 1) {
					return 0
				}
				else {
					var b = buffer!!.toByteArray()
					v = ins!!.read(b)
					b.toUByteArray().copyInto(buffer)
					kotlin.io.println("READ : DONE WITH " + v)
				}
			}
			catch(e: kotlin.Exception) {
				e.printStackTrace()
				v = -1
				kotlin.io.println("READ : FAILED")
			}
		}}}
	}
	if v < 1 {
		PRINT "READING FAILED"
		close()
		v = -1
	}
	return v
}

func write(buffer as buffer, size as int) override as int
{
	assert sslSocket
	if not buffer:
		return -1
	var v = 0
	var channel = sslSocket.getChannel()
	if channel {
		PRINT "WRITE : CHANNEL FOUND"
		lang "kotlin" {{{
			try {
				channel!!.write(java.nio.ByteBuffer.wrap(buffer!!.toByteArray(), 0, size))
				v = size
				kotlin.io.println("WRITE : CHANNEL DONE " + v)
			}
			catch(e: kotlin.Exception)
			{
				e.printStackTrace()
				v = -1
				kotlin.io.println("WRITE : CHANNEL FAILED")
			}
		}}}
	}
	else {
		lang "kotlin" {{{
			try {
				var os = sslSocket!!.getOutputStream()
				os!!.write(buffer!!.toByteArray())
				os!!.flush()
				v = size
				kotlin.io.println("WRITE : DONE " + v)
			}
			catch(e: kotlin.Exception)
			{
				e.printStackTrace()
				v = -1
				kotlin.io.println("WRITE : FAILED")
			}
		}}}
	}
	if v < 1 {
		PRINT "WRITING FAILED"
		close()
		v = -1
	}
	return v
}

func getSocket override as ConnectedSocket:
	return socket

func getSSLSocket as !"javax.net.ssl.SSLSocket":
	return sslSocket
