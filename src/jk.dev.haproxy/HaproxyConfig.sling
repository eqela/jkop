
/*
 * This file is part of Eqela Jkop
 * Copyright (c) 2016-2023 J42 Pte Ltd
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class:

class HostProxyRoute
{
	prop host as string
	prop backends as vector<string>

	func addToBackends(backend as string)
	{
		assert backend
		if not backends:
			backends = new vector<string>
		backends += backend
	}
}

class Frontend
{
	prop port as int
	prop certificatePath as string
	prop rules as vector<object>

	func addToRules(rule as object)
	{
		assert rule
		if not rules:
			rules = new vector<object>
		rules += rule
	}

	func addHostProxy(host as string, backends as array<string>) as HostProxyRoute
	{
		var v = new HostProxyRoute()
		v.host = host
		foreach backend in backends:
			v.addToBackends(backend)
		addToRules(v)
		return v
	}
}

prop uid as int = 5000
prop gid as int = 5000
prop maximumConnections as int = 4096
prop maximumBackendConnections as int = 1024
prop connectTimeout as int = 5
prop clientTimeout as int = 60
prop serverTimeout as int = 60
prop frontends as vector<Frontend>

func addToFrontends(frontend as Frontend)
{
	assert frontend
	if not frontends:
		frontends = new vector<Frontend>
	frontends += frontend
}

func addHttpListener(port as int) as Frontend
{
	var v = new Frontend()
	v.port = port
	addToFrontends(v)
	return v
}

func addHttpsListener(port as int, certificatePath as string) as Frontend
{
	var v = new Frontend()
	v.port = port
	v.certificatePath = certificatePath
	addToFrontends(v)
	return v
}

func generateConfigGlobal(sb as StringBuilder) private
{
	if sb.count() > 0:
		sb.appendString("\n")
	sb.appendString("global\n")
	sb.appendString("  log 127.0.0.1 local0\n")
	sb.appendString("  log 127.0.0.1 local1 notice\n")
	sb.appendString("  maxconn " .. String.forInteger(maximumConnections) .. "\n")
	sb.appendString("  tune.ssl.default-dh-param 2048\n")
	sb.appendString("  uid " .. String.forInteger(uid) .. "\n")
	sb.appendString("  gid " .. String.forInteger(gid) .. "\n")
}

func generateConfigDefaults(sb as StringBuilder) private
{
	if sb.count() > 0:
		sb.appendString("\n")
	sb.appendString("defaults\n")
	sb.appendString("  log global\n")
	sb.appendString("  option httplog\n")
	sb.appendString("  retries 3\n")
	sb.appendString("  timeout connect " .. String.forInteger(connectTimeout) .. "s\n")
	sb.appendString("  timeout client " .. String.forInteger(clientTimeout) .. "s\n")
	sb.appendString("  timeout server " .. String.forInteger(serverTimeout) .. "s\n")
}

func toRuleName(frontendName as string, hostName as string) private as string
{
	var sb = new StringBuilder()
	sb.appendString(frontendName)
	sb.appendCharacter('_')
	var it = String.iterate(hostName)
	while it {
		var c = it.getNextChar()
		if Character.isEOF(c):
			break
		if Character.isLowercaseAlpha(c) || Character.isDigit(c) {
			sb.appendCharacter(c)
		}
		else if Character.isUppercaseAlpha(c) {
			sb.appendCharacter(Character.toLowercase(c))
		}
		else {
			sb.appendCharacter('_')
		}
	}
	return sb.toString()
}

func generateConfigForFrontend(sb as StringBuilder, name as string, frontend as Frontend)
{
	if sb.count() > 0:
		sb.appendString("\n")
	sb.appendString("frontend " .. name .. "\n")
	sb.appendString("  mode http\n")
	if frontend.port > 0 {
		if String.isEmpty(frontend.certificatePath) {
			sb.appendString("  bind *:" .. String.forInteger(frontend.port) .. "\n")
		}
		else {
			sb.appendString("  bind *:" .. String.forInteger(frontend.port) .. " ssl crt " .. frontend.certificatePath .. "\n")
		}
	}

	// generate the acls and the rules

	foreach rule in frontend.rules {
		if rule is HostProxyRoute {
			var hpr = rule as! HostProxyRoute
			var ruleName = toRuleName(name, hpr.host)
			sb.appendString("  acl " .. ruleName .. " hdr(host) -i " .. hpr.host .. "\n")
			sb.appendString("  use_backend " .. ruleName .. "_backend if " .. ruleName .. "\n")
		}
		else {
			Error.throw("unsupportedRule", rule)
		}
	}

	// generate the backend declarations

	foreach rule in frontend.rules {
		if rule is HostProxyRoute {
			var hpr = rule as! HostProxyRoute
			var ruleName = toRuleName(name, hpr.host)
			sb.appendString("\nbackend " .. ruleName .. "_backend\n")
			sb.appendString("  mode http\n")
			sb.appendString("  balance roundrobin\n")
			sb.appendString("  option httpchk\n")
			var n = 1
			foreach backend in hpr.backends {
				sb.appendString("  server server" .. String.forInteger(n) .. " " .. backend .. " maxconn " .. String.forInteger(maximumBackendConnections) .. "\n")
				n ++
			}
		}
		else {
			Error.throw("unsupportedRule", rule)
		}
	}
}

func generateConfig as string
{
	var sb = new StringBuilder()
	generateConfigGlobal(sb)
	generateConfigDefaults(sb)
	var n = 1
	foreach frontend in frontends {
		var name = "frontend" .. String.forInteger(n)
		generateConfigForFrontend(sb, name, frontend)
		n ++
	}
	return sb.toString()
}
