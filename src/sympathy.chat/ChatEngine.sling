
/*
 * This file is part of Jkop
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class abstract:

import cape
import capex.data
import capex.net
import capex.crypto

class UserConnection
{
	prop userId as string
	var connectionMap private as DynamicMap
	var timeStamp private as long = 0

	ctor:
		connectionMap = new DynamicMap()

	func getConnection(connectionId as string) as ChatConnectionHandler
	{
		var connection = connectionMap.get(connectionId) as ChatConnectionHandler
		assert connection && connection.isOpen():
			removeConnectionForId(connectionId)
		return connection
	}

	func addConnection(connection as ChatConnectionHandler)
	{
		assert connection && connection.isOpen()
		connectionMap.set(connection.getConnectionId(), connection)
		timeStamp = -1
	}

	func removeConnectionForId(connectionId as string)
	{
		assert String.isNotEmpty(connectionId)
		connectionMap.remove(connectionId)
		if not isOnline():
			timeStamp = SystemClock.asUTCSeconds()
	}

	func removeConnection(connection as ChatConnectionHandler)
	{
		assert connection
		removeConnectionForId(connection.getConnectionId())
	}

	func getConnectionCount as int
	{
		removeBrokenConnections()
		return connectionMap.getCount()
	}

	func getConnectionIds as vector<string>:
		return connectionMap.getKeys()

	func isOnline as bool:
		return getConnectionCount() > 0

	func getLastActive as long:
		return timeStamp

	func removeBrokenConnections private
	{
		assert connectionMap
		foreach connectionId in getConnectionIds() {
			var connection = connectionMap.get(connectionId) as ChatConnectionHandler
			if not connection || not connection.isOpen():
				removeConnectionForId(connectionId)
		}
	}
}

prop server as WSServer
prop port = 9090
var ctx protected as LoggingContext
var connectionMap private as DynamicMap
var connectionSize private as int
var random private as Random

func authenticateConnection(data as buffer, callback as function<void, string>) abstract
func getUser(userId as string, callback as function<void, ChatUser>) abstract
func getUserCount(callback as function<void, int>) abstract
func createAndSaveChannel(recipients as DynamicVector, creatorUserId as string, callback as function<void, ChatChannel>) abstract
func getChannel(channelId as string, callback as function<void, ChatChannel>) abstract
func createAcknowledgeCommand(userId as string, callback as function<void, ChatMessage>) abstract
func createMessage(data as buffer) abstract as ChatMessage
func saveMessage(message as ChatMessage, newChannelId as string, callback as function<void, Error>) abstract
func onUserOnline(user as ChatUser) abstract
func onUserOffline(user as ChatUser) abstract
func onNewCommandMessage(message as ChatMessage, connection as ChatConnectionHandler) abstract
func handleOfflineRecipients(recipients as DynamicVector, message as ChatMessage) abstract
func checkRecipientsAndSender(recipients as DynamicVector, creatorUserId as string, callback as function<void, bool>) abstract

ctor
{
	connectionMap = new DynamicMap()
	connectionSize = 0
	random = new Random()
}

func initialize virtual as bool:
	return true

func setCtx(ctx as LoggingContext):
	this.ctx = ctx

func getCtx as LoggingContext:
	return ctx

func initializeEngine(mgr as IOManager) as bool
{
	assert mgr:
		logError("No IOManager instance specified.")
	if not server {
		logWarning("No WebSocket server instance specified. Creating a new instance to listen on port: " .. String.forInteger(port) .. ".")
		server = new WSServer()
	}
	server.setPort(port)
	var engine final = this
	server.setCreateConnectionHandlerObject(func as WSServerConnectionHandler {
		return new ChatConnectionHandler().setEngine(engine).setLogContext(ctx)
	})
	assert server.initialize(mgr, ctx):
		logError("Failed to initialize WebSocket server.")
	assert initialize():
		logError("Failed to initialize chat engine.")
	logInfo("Successfully initialized chat engine.")
	return true
}

func generateId virtual as string:
	return MD5Encoder.encode(String.forInteger(SystemClock.asUTCSeconds()) .. String.forInteger(random.nextInt(9999999)) .. String.forInteger(random.nextInt(9999999)) .. String.forInteger(random.nextInt(9999999)))

func logError(message as string):
	Log.error(ctx, VALUE "__THIS__" .. ": " .. message)

func logWarning(message as string):
	Log.warning(ctx, VALUE "__THIS__" .. ": " .. message)

func logInfo(message as string):
	Log.info(ctx, VALUE "__THIS__" .. ": " .. message)

func logDebug(message as string):
	Log.debug(ctx, VALUE "__THIS__" .. ": " .. message)

func onUserDisconnect(userId as string, connection as ChatConnectionHandler)
{
	removeUserConnection(userId, connection)
	connectionSize--
	getUserCount(func(count as int) {
		logDebug("Connection closed. Now: (" .. String.forInteger(connectionSize) .. "/" .. String.forInteger(count) .. ") connected")
	})
	var engine final = this
	getUser(userId, func(user as ChatUser) {
		assert user
		user.setEngine(engine)
		if not user.isOnline() {
			logDebug("User: '" .. userId .. "' is now offline with last active on: " .. String.forLongInteger(getUserLastActive(userId)))
			onUserOffline(user)
		}
	})
}

func addUserConnection(userId as string, connection as ChatConnectionHandler) private
{
	assert String.isNotEmpty(userId) && connection
	var uc = connectionMap.get(userId) as UserConnection
	if not uc {
		uc = new UserConnection()
		uc.setUserId(userId)
		connectionMap.set(userId, uc)
	}
	uc.addConnection(connection)
}

func removeUserConnection(userId as string, connectionId as string)
{
	var uc = assert connectionMap.get(userId) as UserConnection
	uc.removeConnectionForId(connectionId)
}

func removeUserConnection(userId as string, connection as ChatConnectionHandler)
{
	var uc = assert connectionMap.get(userId) as UserConnection
	uc.removeConnection(connection)
}

func onDataReceived(data as buffer, connection as ChatConnectionHandler)
{
	assert connection
	assert data {
		connection.close()
	}
	var user = connection.getUser()
	if not user {
		onAuthenticateConnection(data, connection)
		return
	}
	onParseData(data, connection)
}

func onAuthenticateConnection(data as buffer, connection as ChatConnectionHandler) private
{
	var engine final = this
	authenticateConnection(data, func(userId as string) {
		assert String.isNotEmpty(userId) {
			logError("No userId returned by authenticateConnection() abstract method. Closing the connection instead.")
			connection.close()
		}
		getUser(userId, func(user as ChatUser) {
			assert user {
				logError("No ChatUser instance returned by getUser() abstract method. Closing the connection instead.")
				connection.close()
			}
			user.setEngine(engine)
			connection.setUser(user)
			loop {
				var connectionId = generateId()
				assert String.isNotEmpty(connectionId) {
					logError("No connectionId returned by generateId() abstract method. Closing the connection instead.")
					connection.close()
				}
				if not user.getConnection(connectionId) {
					connection.setConnectionId(connectionId)
					break
				}
			}
			addUserConnection(userId, connection)
			connectionSize++
			getUserCount(func(count as int) {
				logDebug("New connection. Now: (" .. String.forInteger(connectionSize) .. "/" .. String.forInteger(count) .. ") connected")
			})
			createAcknowledgeCommand(userId, func(message as ChatMessage) {
				assert message {
					logError("Failed to create an acknowledge command message that the client is connected. Closing the connection instead.")
					connection.close()
				}
				assert message.getMessageType() == ChatMessage.COMMAND_TYPE {
					logError("Acknowledge command message not of type command. Closing the connection instead.")
					connection.close()
				}
				var r = connection.sendMessage(message)
				assert r > 0 {
					logError("Failed to send message. Closing the connection instead.")
					connection.close()
				}
				if user.getConnectionCount() == 1 {
					logDebug("User: '" .. user.getUserId() .. "' is now online")
					onUserOnline(user)
				}
			})
		})
	})
}

func onParseData(data as buffer, connection as ChatConnectionHandler) private
{
	assert data {
		logError("No data buffer received. Closing the connection instead.")
		connection.close()
	}
	var message = assert createMessage(data) {
		logError("No ChatMessage instance returned by createMessage() abstract method. Closing the connection instead.")
		connection.close()
	}
	assert String.isEmpty(message.getMessageId()) {
		logError("ChatMessage instance returned by createMessage() abstract method should not be saved and have message id yet. Closing the connection instead.")
		connection.close()
	}
	switch message.getMessageType() {
		case ChatMessage.COMMAND_TYPE: {
			// We would want to have commands
			// like: SEEN, TYPING, ONLINE, OFFLINE,
			// UPLOADING_FILE, DONE_UPLOADING_FILE, etc.
			onNewCommandMessage(message, connection)
			break
		}
		case ChatMessage.DATA_TYPE: {
			onNewDataMessage(message, connection)
			break
		}
		default: {
			logError("ChatMessage message type is invalid. Closing the connection instead.")
			connection.close()
		}
	}
}

func onNewDataMessage(message as ChatMessage, connection as ChatConnectionHandler)
{
	assert message && message.getMessageType() == ChatMessage.DATA_TYPE:
		connection.close()
	var creatorUserId = message.getCreatorUserId()
	assert String.isNotEmpty(creatorUserId):
		connection.close()
	var channelId = message.getChannelId()
	if String.isEmpty(channelId) {
		createChannelAndGetId(message.getRecipients(), creatorUserId, func(newChannelId as string) {
			getChannel(newChannelId, func(channel as ChatChannel) {
				assert channel && String.equals(channel.getChannelId(), newChannelId):
					connection.close()
				onSaveMessage(message, channel, connection)
			})
		})
		return
	}
	getChannel(channelId, func(channel as ChatChannel) {
		assert channel && String.equals(channel.getChannelId(), channelId):
			connection.close()
		onSaveMessage(message, channel, connection)
	})
}

func createChannelAndGetId(recipients as DynamicVector, creatorUserId as string, callback as function<void, string>) private
{
	checkRecipientsAndSender(recipients, creatorUserId, func(valid as bool) {
		assert valid {
			logError("No creatorUserId or recipients or recipient count is less than two returned by checkRecipientsAndSender() method.")
			callback(null)
		}
		createAndSaveChannel(recipients, creatorUserId, func(channel as ChatChannel) {
			assert channel {
				logError("No ChatChannel instance returned by createChannel() abstract method.")
				callback(null)
			}
			var channelId = channel.getChannelId()
			assert String.isNotEmpty(channelId) {
				logError("Created ChatChannel instance returned by createChannel() abstract method doesn't have channelId.")
				callback(null)
			}
			logDebug("New channel '" .. channelId .. "' created")
			callback(channelId)
		})
	})
}

func onSaveMessage(message as ChatMessage, channel as ChatChannel, connection as ChatConnectionHandler) private
{
	channel.setEngine(this)
	saveMessage(message, channel.getChannelId(), func(error as Error) {
		assert not error:
			connection.close()
		assert String.isNotEmpty(message.getMessageId()):
			connection.close()
		assert String.equals(message.getChannelId(), channel.getChannelId()):
			connection.close()
		channel.onNewDataMessage(message, connection)
	})
}

func getUserConnection(userId as string, connectionId as string) as ChatConnectionHandler
{
	assert String.isNotEmpty(userId) && String.isNotEmpty(connectionId)
	var uc = assert connectionMap.get(userId) as UserConnection
	return uc.getConnection(connectionId)
}

func getUserConnectionCount(userId as string) as int
{
	assert String.isNotEmpty(userId)
	var uc = assert connectionMap.get(userId) as UserConnection
	return uc.getConnectionCount()
}

func getUserConnectionIds(userId as string) as vector<string>
{
	assert String.isNotEmpty(userId)
	var uc = assert connectionMap.get(userId) as UserConnection
	return uc.getConnectionIds()
}

func isUserOnline(userId as string) as bool
{
	assert String.isNotEmpty(userId)
	var uc = assert connectionMap.get(userId) as UserConnection
	return uc.isOnline()
}

func getUserLastActive(userId as string) as long
{
	assert String.isNotEmpty(userId)
	var uc = assert connectionMap.get(userId) as UserConnection
	return uc.getLastActive()
}

func broadcastMessage(message as ChatMessage)
{
	assert message
	var recipients = message.getRecipients()
	assert recipients && recipients.getSize() > 0
	var creatorUserId = message.getCreatorUserId()
	if String.isNotEmpty(creatorUserId) && recipients.contains(creatorUserId):
		recipients.removeValue(creatorUserId)
	var offlineRecipients = new DynamicVector()
	foreach userId in recipients.toVectorOfStrings() {
		if not isUserOnline(userId) {
			logDebug("User: '" .. userId .. "' is offline with last active on: " .. String.forLongInteger(getUserLastActive(userId)) .. ". Would send a notification instead.")
			offlineRecipients.append(userId)
			continue
		}
		var brokenConnections = new vector<string>
		foreach connectionId in getUserConnectionIds(userId) {
			var connection = getUserConnection(userId, connectionId)
			if not connection || not connection.isOpen() {
				brokenConnections += connectionId
				continue
			}
			var r = connection.sendMessage(message)
			if r < 1:
				brokenConnections += connectionId
		}
		foreach connectionId in brokenConnections:
			removeUserConnection(userId, connectionId)
		if not isUserOnline(userId) {
			logDebug("User: '" .. userId .. "' is offline with last active on: " .. String.forLongInteger(getUserLastActive(userId)) .. ". Would send a notification instead.")
			offlineRecipients.append(userId)
		}
	}
	if offlineRecipients.getSize() > 0:
		handleOfflineRecipients(recipients, message)
}
