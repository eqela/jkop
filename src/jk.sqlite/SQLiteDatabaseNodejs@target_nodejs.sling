
/*
 * This file is part of Eqela Jkop
 * Copyright (c) 2016-2023 J42 Pte Ltd
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import jk.sql
import jk.nodejs
import jk.fs
import jk.log

class is SQLiteDatabase:

depend "npm:better-sqlite3:8.4.0"

var sqldatabase private as !"sqlite.Database"

class Statement is SQLStatement
{
	var isStoredProcedure = false
	var sqlitedb as !"sqlite.Database"
	var params = new vector
	var error as string
	var sqlPreparedStmt as !"sqlite.Statement"

	func setIsStoredProcedure(v as bool) as SQLStatement
	{
		isStoredProcedure = v
		return this
	}

	func getIsStoredProcedure as bool:
		return isStoredProcedure

	func create(db as !"sqlite.Database", statement as string) as bool
	{
		assert db
		var v = true
		try {
			sqlitedb = db
			sqlPreparedStmt = sqlitedb.prepare(statement)
		}
		catch (e) {
			v = false
		}
		return v
	}

	func addParamString(val as string) as SQLStatement
	{
		Vector.append(params, val)
		return this
	}

	func addParamInteger(val as int) as SQLStatement
	{
		Vector.append(params, val)
		return this
	}

	func addParamLongInteger(val as long) as SQLStatement
	{
		Vector.append(params, val)
		return this
	}

	func addParamDouble(val as double) as SQLStatement
	{
		Vector.append(params, val)
		return this
	}

	func addParamBlob(val as buffer) as SQLStatement
	{
		Vector.append(params, val)
		return this
	}

	func setParamString(name as string, val as string) as SQLStatement:
		return addParamString(val)

	func setParamInteger(name as string, val as int) as SQLStatement:
		return addParamInteger(val)

	func setParamLongInteger(name as string, val as long) as SQLStatement:
		return addParamLongInteger(val)

	func setParamDouble(name as string, val as double) as SQLStatement:
		return addParamDouble(val)

	func setParamBlob(name as string, val as buffer) as SQLStatement:
		return addParamBlob(val)

	func getError as string:
		return error

	func resetStatement:
		Vector.clear(params)

	func close
	{
		resetStatement()
		sqlPreparedStmt = null
	}

	func executeUpdateDelete as int
	{
		assert sqlPreparedStmt
		var v = 0
		try {
			var result = sqlPreparedStmt.run(params)
			v = Integer.asInteger(result.changes)
		}
		catch (e) {
			error = "Failed to execute prepared statement: " + String.asString(e)
		}
		return v
	}

	func execute as bool
	{
		assert sqlPreparedStmt
		var b as bool
		try {
			sqlPreparedStmt.run(params)
			b = true
		}
		catch (e) {
			error = "Failed to execute prepared statement: " + String.asString(e)
			b = false
		}
		return b
	}

	func getIteratorStmt as !"sqlite.Statement"
	{
		assert sqlPreparedStmt
		var rowIteratorStmt as !"sqlite.Statement"
		try {
			rowIteratorStmt = sqlPreparedStmt.bind(params)
		}
		catch (e) {
			error = "Failed to get prepared statement: " + String.asString(e)
		}
		return rowIteratorStmt
	}
}

class ResultSet is SQLResultSetIterator
{
	var currentRowValue as vector
	var rawColumnData as vector
	var columnNames = new vector<string>
	var iterator as !"sqlite.Iterator"

	ctor(stmt as Statement):
		initialize(stmt.getIteratorStmt())

	func initialize(stmt as !"sqlite.Statement")
	{
		rawColumnData = stmt.columns() as vector
		iterator = stmt.raw().iterate()
	}

	func next override as DynamicMap 
	{
		var data as DynamicMap
		if not step():
			return null
		var columns = getColumnNames()
		data = new DynamicMap()
		for(var i = 0; i < Vector.getSize(columns); i++):
			data.setObject(Vector.get(columns, i), getColumnObject(i))
		return data
	}

	func nextValues(values as vector<object>) override as bool
	{
		assert values
		if not step():
			return false
		Vector.clear(values)
		var columns = getColumnCount()
		for(var i = 0; i < columns; i++):
			values += getColumnObject(i)
		return true
	}

	func getColumnName(n as int #used) override as string:
		return String.asString(Vector.get(rawColumnData as vector, n).name)

	func getColumnCount override as int:
		return Integer.asInteger(Vector.getSize(rawColumnData))

	func getColumnNames override as vector<string>
	{
		if Vector.getSize(columnNames) > 0:
			return columnNames
		var itr = Vector.iterate(rawColumnData)
		loop {
			var next = itr.next()
			if not next:
				break
			Vector.append(columnNames, String.asString(next.name))
		}
		return columnNames
	}

	func getColumnObject(n as int) override as object
	{
		var type = String.asString(Vector.get(rawColumnData, n).type)
		if type == null && String.asString(Vector.get(rawColumnData, n).name) != null:
			type = "TEXT"
		if type == "INTEGER":
			return Integer.asObject(getColumnInt(n))
		else if type == "BIGINT":
			return LongInteger.asObject(getColumnLong(n))
		else if type == "BLOB":
			return Buffer.asObject(getColumnBuffer(n))
		else if type == "DOUBLE" || type == "REAL":
			return Double.asObject(getColumnDouble(n))
		else if type == "TEXT" || type == "VARCHAR(255)":
			return getColumnString(n)
		else:
			Error.throw("Unsupported type", type)
		return null
	}

	func getColumnInt(n as int) override as int:
		return Integer.asInteger(currentRowValue[n])

	func getColumnDouble(n as int) override as double:
		return Double.asDouble(currentRowValue[n])

	func getColumnBuffer(n as int) override as buffer:
		return Buffer.asBuffer(currentRowValue[n])

	func getColumnString(n as int) as string:
		return String.asString(currentRowValue[n])

	func getColumnLong(n as int) override as long:
		return LongInteger.asLong(currentRowValue[n])

	func step override as bool 
	{
		if not hasNext():
			return false
		return true
	}

	func hasNext override as bool
	{
		var itr = iterator.next()
		if itr.done == true:
			return false
		currentRowValue = itr.value as vector
		return true
	}

	func close override
	{
		rawColumnData = null
		columnNames = null
		iterator = null
		currentRowValue = null
	}
}

func initialize(file as File, openCreate as bool) override as bool
{
	assert file
	var sqlite = NodeModule.require("better-sqlite3")
	var ctx as LoggingContext
	if openCreate == false && file.isFile() == false {
		Log.error(ctx, "Database does not exist: " .. file.getPath())
		return false
	}
	var filePath = file.getPath()
	if filePath == null {
		Log.error(ctx, "Database file '" .. file.getPath() .. "' is empty.")
		return false
	}
	var v = true
	try {
		sqldatabase = sqlite(String.asString(file)) 
	}
	catch (e) {
		v = false
	}
	if v {
		Log.debug(ctx, "Opened Sqlite database: '" .. file.getPath() .. "'")
	}
	else {
		if openCreate:
			Log.error(ctx, "Failed to create database. Please check write permissions")
	}
	return v
}

func closeConnection async override 
{
	lang "js" {{{
		if (this.sqldatabase !== null) {
			this.sqldatabase.close()
			this.sqldatabase = null
		}
	}}}
}

func prepareStatement(sql as string) async override as SQLStatement 
{
	var stmt = new Statement()
	if not stmt.create(sqldatabase, sql):
		return null
	return stmt
}

func executeStatement(stmt as SQLStatement) async override as bool 
{
	assert stmt
	var v as bool
	var ss = stmt as Statement
	if ss:
		v = ss.execute()
	return v
}

func executeQueryStatement(stmt as SQLStatement) async override as SQLResultSetIterator 
{
	assert stmt
	var ss = stmt as Statement
	var ctx as LoggingContext
	if not ss {
		Log.debug(ctx, "SQLite query: null statement")
		return null
	}
	return new ResultSet(ss)
}

func executeUpdateDeleteStatement(stmt as SQLStatement) async override as int
{
	var v = 0
	var ss = stmt as Statement
	if ss:
		v = ss.executeUpdateDelete()
	return v
}
