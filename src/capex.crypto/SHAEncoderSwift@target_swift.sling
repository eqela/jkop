
/*
 * This file is part of Jkop
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class is SHAEncoder imports cape:

func encodeAsBuffer(data as buffer, version as int) override as buffer
{
	assert data
	var algorithm as int
	if SHAEncoder.ANY == version || SHAEncoder.SHA1 == version {
		algorithm = 128
	}
	else if SHAEncoder.SHA256 == version {
		algorithm = 256
	}
	else if SHAEncoder.SHA384 == version {
		algorithm = 384
	}
	else if SHAEncoder.SHA512 == version {
		algorithm = 512
	}
	assert algorithm
	lang "swift" {{{
		var sha = SHA(data, algorithm)
		return sha.digest()
	}}}
}

func encodeAsString(data as buffer, version as int) override as string
{
	var digest = assert encodeAsBuffer(data, version)
	var result as string #used
	lang "swift" {{{
		let value = digest.reduce("") {
			var str = String($1, radix: 16)
			if str.count == 1 {
				str = "0" + str
			}
			return $0 + str
		}
		result = value
	}}}
	return result
}

lang "swift" {{{
	public class SHA {
		let SHA128: Int = 160
		let SHA256: Int = 256
		let SHA384: Int = 384
		let SHA512: Int = 512
		let blockSize512: Int = 512
		let blockSize1024: Int = 1024
		let block64: Int = 448
		let block128: Int = 896
		var digestLength: Int
		var blockBitSize: Int
		var k: [UInt32]?
		var k2: [UInt64]?
		var hash: [UInt32]?
		var hash2: [UInt64]?
		var input: [UInt8]
		var result: [UInt8]?

		public init(_ input: [UInt8], _ variant: Int) {
			self.input = input
			if variant == 128 {
				digestLength = SHA128
				blockBitSize = blockSize512
				hash = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]
			}
			else if variant == SHA256 {
				digestLength = SHA256
				blockBitSize = blockSize512
				hash = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]
				k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
					0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
					0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
					0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
					0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
					0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
					0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
					0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]
			}
			else if variant == SHA384 {
				digestLength = SHA384
				blockBitSize = blockSize1024
				hash2 = [0xcbbb9d5dc1059ed8, 0x629a292a367cd507, 0x9159015a3070dd17, 0x152fecd8f70e5939, 0x67332667ffc00b31, 0x8eb44a8768581511, 0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4]
				k2 = [0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc, 0x3956c25bf348b538, 
					0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118, 0xd807aa98a3030242, 0x12835b0145706fbe, 
					0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2, 0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 
					0xc19bf174cf692694, 0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65, 
					0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5, 0x983e5152ee66dfab, 
					0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4, 0xc6e00bf33da88fc2, 0xd5a79147930aa725, 
					0x06ca6351e003826f, 0x142929670a0e6e70, 0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 
					0x53380d139d95b3df, 0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b, 
					0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30, 0xd192e819d6ef5218, 
					0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8, 0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 
					0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8, 0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 
					0x682e6ff3d6b2b8a3, 0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec, 
					0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b, 0xca273eceea26619c, 
					0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178, 0x06f067aa72176fba, 0x0a637dc5a2c898a6, 
					0x113f9804bef90dae, 0x1b710b35131c471b, 0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 
					0x431d67c49c100d4c, 0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817]
			}
			else {
				digestLength = SHA512
				blockBitSize = blockSize1024
				hash2 = [0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1, 0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179]
				k2 = [0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc, 0x3956c25bf348b538,
					0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118, 0xd807aa98a3030242, 0x12835b0145706fbe,
					0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2, 0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235,
					0xc19bf174cf692694, 0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
					0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5, 0x983e5152ee66dfab,
					0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4, 0xc6e00bf33da88fc2, 0xd5a79147930aa725,
					0x06ca6351e003826f, 0x142929670a0e6e70, 0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed,
					0x53380d139d95b3df, 0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
					0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30, 0xd192e819d6ef5218,
					0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8, 0x19a4c116b8d2d0c8, 0x1e376c085141ab53,
					0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8, 0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373,
					0x682e6ff3d6b2b8a3, 0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
					0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b, 0xca273eceea26619c,
					0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178, 0x06f067aa72176fba, 0x0a637dc5a2c898a6,
					0x113f9804bef90dae, 0x1b710b35131c471b, 0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc,
					0x431d67c49c100d4c, 0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817]
			}
		}

		public func digest() -> [UInt8] {
			if let result = self.result {
				return result
			}
			bitPadding(&input)
			let messageBlocks = input.blocks(size: blockBitSize / 8)
			for block in messageBlocks {
				if blockBitSize == blockSize512 {
					shaProcess32(block)
				}
				else {
					shaProcess64(block)
				}
			}
			var result = [UInt8](repeating: 0, count: digestLength / 8)
			if blockBitSize == blockSize512 {
				for (idx, element) in hash!.enumerated() {
					let pos = idx * 4
					result[pos + 0] = UInt8((element >> 24) & 0xff)
					result[pos + 1] = UInt8((element >> 16) & 0xff)
					result[pos + 2] = UInt8((element >> 8) & 0xff)
					result[pos + 3] = UInt8(element & 0xff)
				}
			}
			else {
				for (idx, element) in hash2!.enumerated() {
					if digestLength == SHA384 && idx == 6 {
						break
					}
					let pos = idx * 8
					result[pos + 0] = UInt8((element >> 56) & 0xff)
					result[pos + 1] = UInt8((element >> 48) & 0xff)
					result[pos + 2] = UInt8((element >> 40) & 0xff)
					result[pos + 3] = UInt8((element >> 32) & 0xff)
					result[pos + 4] = UInt8((element >> 24) & 0xff)
					result[pos + 5] = UInt8((element >> 16) & 0xff)
					result[pos + 6] = UInt8((element >> 8) & 0xff)
					result[pos + 7] = UInt8(element & 0xff)
				}
			}
			self.result = result
			return result
		}

		func shaProcess64(_ block: ArraySlice<UInt8>) {
			var M = [UInt64](repeating: 0, count: k2!.count)
			for t in 0..<M.count {
				switch t {
				case 0...15:
					let index = block.startIndex.advanced(by: t * 8)
					M[t] = UInt64(block[index + 0]) << 56
					M[t] |= UInt64(block[index + 1]) << 48
					M[t] |= UInt64(block[index + 2]) << 40
					M[t] |= UInt64(block[index + 3]) << 32
					M[t] |= UInt64(block[index + 4]) << 24
					M[t] |= UInt64(block[index + 5]) << 16
					M[t] |= UInt64(block[index + 6]) << 8
					M[t] |= UInt64(block[index + 7])
				default:
					let s0 = M[t-15].rotateRight(by: 1) ^ M[t-15].rotateRight(by: 8) ^ (M[t-15] >> 7)
					let s1 = M[t-2].rotateRight(by: 19) ^ M[t-2].rotateRight(by: 61) ^ (M[t-2] >> 6)
					M[t] = s1 &+ M[t-7] &+ s0 &+ M[t-16]
				}
			}
			var a = hash2![0]
			var b = hash2![1]
			var c = hash2![2]
			var d = hash2![3]
			var e = hash2![4]
			var f = hash2![5]
			var g = hash2![6]
			var h = hash2![7]
			for t in 0..<k2!.count {
				let Σ0 = a.rotateRight(by: 28) ^ a.rotateRight(by: 34) ^ a.rotateRight(by: 39)
				let maj = (a & b) ^ (a & c) ^ (b & c)
				let t2 = Σ0 &+ maj
				let Σ1 = e.rotateRight(by: 14) ^ e.rotateRight(by: 18) ^ e.rotateRight(by: 41)
				let ch = (e & f) ^ (~e & g)
				let t1 = h &+ Σ1 &+ ch &+ k2![t] &+ UInt64(M[t])
				h = g
				g = f
				f = e
				e = d &+ t1
				d = c
				c = b
				b = a
				a = t1 &+ t2
			}
			hash2![0] = a &+ hash2![0]
			hash2![1] = b &+ hash2![1]
			hash2![2] = c &+ hash2![2]
			hash2![3] = d &+ hash2![3]
			hash2![4] = e &+ hash2![4]
			hash2![5] = f &+ hash2![5]
			hash2![6] = g &+ hash2![6]
			hash2![7] = h &+ hash2![7]
		}

		func shaProcess32(_ block: ArraySlice<UInt8>) {
			var kcount: Int
			if digestLength == SHA128 {
				kcount = 80
			}
			else {
				kcount = k!.count
			}
			var M = [UInt32](repeating: 0, count: kcount)
			for t in 0..<M.count {
				switch t {
				case 0...15:
					let index = block.startIndex.advanced(by: t * 4)
					M[t]  = UInt32(block[index + 0]) << 24
					M[t] |= UInt32(block[index + 1]) << 16
					M[t] |= UInt32(block[index + 2]) << 8
					M[t] |= UInt32(block[index + 3])
				default:
					if digestLength == SHA128 {
						M[t] = M[t - 3].rotateLeft(by: 1) ^ M[t - 8].rotateLeft(by: 1) ^ M[t - 14].rotateLeft(by: 1) ^ M[t - 16].rotateLeft(by: 1)
					}
					else {
						let s0 = M[t-15].rotateRight(by: 7) ^ M[t-15].rotateRight(by: 18) ^ (M[t-15] >> 3)
						let s1 = M[t-2].rotateRight(by: 17) ^ M[t-2].rotateRight(by: 19) ^ (M[t-2] >> 10)
						M[t] = s1 &+ M[t-7] &+ s0 &+ M[t-16]
					}
				}
			}
			var a = hash![0]
			var b = hash![1]
			var c = hash![2]
			var d = hash![3]
			var e = hash![4]
			if digestLength == SHA128 {
				for j in 0...79 {
					var f: UInt32 = 0
					var k: UInt32 = 0

					switch j {
					case 0...19:
						f = (b & c) | ((~b) & d)
						k = 0x5a827999
						break
					case 20...39:
						f = b ^ c ^ d
						k = 0x6ed9eba1
						break
					case 40...59:
						f = (b & c) | (b & d) | (c & d)
						k = 0x8f1bbcdc
						break
					case 60...79:
						f = b ^ c ^ d
						k = 0xca62c1d6
						break
					default:
						break
					}
					let temp = a.rotateLeft(by: 5) &+ f &+ e &+ M[j] &+ k
					e = d
					d = c
					c = b.rotateLeft(by: 30)
					b = a
					a = temp
				}
				hash![0] = a &+ hash![0]
				hash![1] = b &+ hash![1]
				hash![2] = c &+ hash![2]
				hash![3] = d &+ hash![3]
				hash![4] = e &+ hash![4]
			}
			else {
				var f = hash![5]
				var g = hash![6]
				var h = hash![7]
				for t in 0..<k!.count {
					let Σ1 = e.rotateRight(by: 6) ^ e.rotateRight(by: 11) ^ e.rotateRight(by: 25)
					let ch = (e & f) ^ (~e & g)
					let t1 = h &+ Σ1 &+ ch &+ k![t] &+ M[t]
					let Σ0 = a.rotateRight(by: 2) ^ a.rotateRight(by: 13) ^ a.rotateRight(by: 22)
					let maj = (a & b) ^ (a & c) ^ (b & c)
					let t2 = Σ0 &+ maj
					h = g
					g = f
					f = e
					e = d &+ t1
					d = c
					c = b
					b = a
					a = t1 &+ t2
				}
				hash![0] = a &+ hash![0]
				hash![1] = b &+ hash![1]
				hash![2] = c &+ hash![2]
				hash![3] = d &+ hash![3]
				hash![4] = e &+ hash![4]
				hash![5] = f &+ hash![5]
				hash![6] = g &+ hash![6]
				hash![7] = h &+ hash![7]
			}
		}

		func bitPadding(_ input: inout [UInt8]) {
			let inputBitLength = input.count * 8
			input.append(0x80)
			let mod = inputBitLength % blockBitSize
			if blockBitSize == blockSize512 {
				let bitsToAppend = mod < block64 ? block64 - 1 - mod : blockBitSize + block64 - mod - 1
				input += [UInt8](repeating: 0, count: (bitsToAppend - 7) / 8)
			}
			else {
				let bitsToAppend = mod < block128 ? block128 - 1 - mod : blockBitSize + block128 - mod - 1
				input += [UInt8](repeating: 0, count: ((bitsToAppend - 7) + 64) / 8)
			}
			for byte in UInt64(inputBitLength).toByteArray().lazy.reversed() {
				input.append(byte)
			}
		}
	}

	private extension UInt64 {
		func toByteArray() -> [UInt8] {
			var value = self.littleEndian
			return withUnsafeBytes(of: &value, Array.init)
		}
	}

	private extension UInt32 {
		func rotateRight(by amount: UInt32) -> UInt32 {
			return (self >> amount) | (self << (32 - amount))
		}
	}

	private extension UInt64 {
		func rotateRight(by amount: UInt64) -> UInt64 {
			return (self >> amount) | (self << (64 - amount))
		}
	}

	private extension UInt32 {
		func rotateLeft(by amount: UInt32) -> UInt32 {
			return (self << amount) | (self >> (32 - amount))
		}
	}

	private extension Array {
		func blocks(size: Int) -> AnyIterator<ArraySlice<Element>> {
			var currentIndex = startIndex
			return AnyIterator {
				if let nextIndex = self.index(currentIndex, offsetBy: size, limitedBy: self.endIndex) {
					defer { currentIndex = nextIndex }
					return self[currentIndex..<nextIndex]
				}
				return nil
			}
		}
	}
}}}
