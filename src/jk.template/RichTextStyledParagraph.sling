
/*
 * This file is part of Jkop
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 * Copyright (c) 2018-2020 Eqela Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class is RichTextParagraph:

func forString(text as string) static as this
{
	var rtsp = new this()
	return rtsp.parse(text)
}

pvar heading = 0
pvar segments as vector<RichTextSegment>

func isHeading as bool
{
	if heading > 0:
		return true
	return false
}

func getTextContent as string
{
	var sb = new StringBuilder()
	foreach segment as RichTextSegment in segments:
		sb.appendString(segment.getText())
	return sb.toString()
}

func toJson override as DynamicMap
{
	var segs = new vector<object>
	foreach segment as RichTextSegment in segments {
		var segj = segment.toJson()
		if segj:
			Vector.append(segs, segj)
	}
	var v = new DynamicMap()
	v.setString("type", "styled")
	v.setInteger("heading", heading)
	v.setObject("segments", segs)
	return v
}

func toText override as string
{
	var sb = new StringBuilder()
	foreach sg as RichTextSegment in segments {
		sb.appendString(sg.getText())
		var link = sg.getLink()
		if String.isEmpty(link) == false:
			sb.appendString(" (" .. link .. ")")
		var ref = sg.getReference()
		if String.isEmpty(ref) == false:
			sb.appendString(" {" .. ref.. "}")
	}
	return sb.toString()
}

func toHtml(refs as RichTextDocumentReferenceResolver) override as string
{
	var sb = new StringBuilder()
	var tag = "p"
	if heading > 0:
		tag = "h" .. String.forInteger(heading)
	sb.appendString("<")
	sb.appendString(tag)
	sb.appendString(">")
	foreach sg as RichTextSegment in segments:
		sb.appendString(sg.toHtml(refs))
	sb.appendString("</"  .. tag .. ">")
	return sb.toString()
}

func addSegment(rts as RichTextSegment) as RichTextParagraph
{
	if rts == null:
		return this
	if segments == null:
		segments = new vector<RichTextSegment>
	Vector.append(segments, rts)
	return this
}

func setSegmentLink(seg as RichTextSegment, alink as string)
{
	if alink == null {
		seg.setLink(null)
		return
	}
	var link = alink
	if String.startsWith(link, ">") {
		seg.setIsInline(true)
		link = String.getEndOfString(link, 1)
	}
	if String.startsWith(link, "!") {
		seg.setLinkPopup(false)
		link = String.getEndOfString(link, 1)
	}
	else {
		seg.setLinkPopup(true)
	}
	seg.setLink(link)
}

func parseSegments(txt as string)
{
	assert txt
	var segmentsb as StringBuilder
	var linksb as StringBuilder
	var sb = new StringBuilder()
	var it = String.iterate(txt)
	var c as char
	var pc = 0 as char
	var seg = new RichTextSegment()
	while (c = it.getNextChar()) > 0 {
		if pc == '[' {
			if c == '[' {
				sb.appendCharacter(c)
				pc = 0 as char
				continue
			}
			if sb.count() > 0 {
				seg.setText(sb.toString())
				sb.clear()
				addSegment(seg)
			}
			seg = new RichTextSegment()
			linksb = new StringBuilder()
			linksb.appendCharacter(c)
			pc = c
			continue
		}
		if linksb {
			if c == '|' {
				setSegmentLink(seg, linksb.toString())
				linksb.clear()
				pc = c
				continue
			}
			if c == ']' {
				var xt = linksb.toString()
				if seg.getLink() == null {
					setSegmentLink(seg, xt)
				}
				else {
					seg.setText(xt)
				}
				if String.isEmpty(seg.getText()) {
					var ll = xt
					if String.startsWith(ll, "http://"):
						ll = String.getEndOfString(ll, 7)
					seg.setText(ll)
				}
				addSegment(seg)
				seg = new RichTextSegment()
				linksb = null
			}
			else {
				linksb.appendCharacter(c)
			}
			pc = c
			continue
		}
		if pc == '{' {
			if c == '{' {
				sb.appendCharacter(c)
				pc = 0 as char
				continue
			}
			if sb.count() > 0 {
				seg.setText(sb.toString())
				sb.clear()
				addSegment(seg)
			}
			seg = new RichTextSegment()
			segmentsb = new StringBuilder()
			segmentsb.appendCharacter(c)
			pc = c
			continue
		}
		if segmentsb {
			if c == '|' {
				seg.setReference(segmentsb.toString())
				segmentsb.clear()
				pc = c
				continue
			}
			if c == '}' {
				var xt = segmentsb.toString()
				if seg.getReference() == null {
					seg.setReference(xt)
				}
				else {
					seg.setText(xt)
				}
				addSegment(seg)
				seg = new RichTextSegment()
				segmentsb = null
			}
			else {
				segmentsb.appendCharacter(c)
			}
			pc = c
			continue
		}
		if pc == '*' {
			if c == '*' {
				if sb.count() > 0 {
					seg.setText(sb.toString())
					sb.clear()
					addSegment(seg)
				}
				if seg.getBold() {
					seg = new RichTextSegment().setBold(false)
				}
				else {
					seg = new RichTextSegment().setBold(true)
				}
			}
			else {
				sb.appendCharacter(pc)
				sb.appendCharacter(c)
			}
			pc = 0 as char
			continue
		}
		if pc == '_' {
			if c == '_' {
				if sb.count() > 0 {
					seg.setText(sb.toString())
					sb.clear()
					addSegment(seg)
				}
				if seg.getUnderline() {
					seg = new RichTextSegment().setUnderline(false)
				}
				else {
					seg = new RichTextSegment().setUnderline(true)
				}
			}
			else {
				sb.appendCharacter(pc)
				sb.appendCharacter(c)
			}
			pc = 0 as char
			continue
		}
		if pc == '\'' {
			if c == '\'' {
				if sb.count() > 0 {
					seg.setText(sb.toString())
					sb.clear()
					addSegment(seg)
				}
				if seg.getItalic() {
					seg = new RichTextSegment().setItalic(false)
				}
				else {
					seg = new RichTextSegment().setItalic(true)
				}
			}
			else {
				sb.appendCharacter(pc)
				sb.appendCharacter(c)
			}
			pc = 0 as char
			continue
		}
		if c != '*' && c != '_' && c != '\'' && c != '{' && c != '[':
			sb.appendCharacter(c)
		pc = c
	}
	if pc == '*' || pc == '_' || pc == '\'' && pc != '{' && pc != '[':
		sb.appendCharacter(pc)
	if sb.count() > 0 {
		seg.setText(sb.toString())
		sb.clear()
		addSegment(seg)
	}
}

func parse(text as string) as this
{
	if text == null:
		return this
	var txt = text
	var prefixes = new string[] { "=", "==", "===", "====", "=====" }
	var n as int
	for(n=0 ; n<sizeof prefixes; n++) {
		var key = prefixes[n]
		if String.startsWith(txt, key .. " ") && String.endsWith(txt, " " .. key) {
			setHeading(n+1)
			txt = String.getSubString(txt, String.getLength(key)+1, String.getLength(txt)-String.getLength(key)*2-2)
			if txt:
				txt = String.strip(txt)
			break
		}
	}
	parseSegments(txt)
	return this
}

func toMarkup override as string
{
	var ident as string
	if heading == 1 {
		ident = "="
	}
	else if heading == 2 {
		ident = "=="
	}
	else if heading == 3 {
		ident = "==="
	}
	else if heading == 4 {
		ident = "===="
	}
	else if heading == 5 {
		ident = "====="
	}
	var sb = new StringBuilder()
	if String.isEmpty(ident) == false {
		sb.appendString(ident)
		sb.appendCharacter(' ')
	}
	foreach segment as RichTextSegment in segments:
		sb.appendString(segment.toMarkup())
	if String.isEmpty(ident) == false {
		sb.appendCharacter(' ')
		sb.appendString(ident)
	}
	return sb.toString()
}
