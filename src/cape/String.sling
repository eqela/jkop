
/*
 * This file is part of Jkop
 * Copyright (c) 2016 Job and Esther Technologies, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

**
** The String class provides all the common string manipulation functions,
** including comparisons, concatenation, transformations to upper and lowercase,
** getting substrings, finding characters or substrings, splitting the strings,
** converting to byte buffers, etc.
**

class:

**
** Converts an arbitrary object to a string, if possible.
**

func asString(obj as object) static as string
{
	if(obj == null) {
		return(null)
	}
	if(obj is string) {
		return(obj as! string)
	}
	if(obj is StringObject) {
		return((obj as! StringObject).toString())
	}
	if(obj is IntegerObject) {
		return(forInteger((obj as! IntegerObject).toInteger()))
	}
	if(obj is DoubleObject) {
		return(forDouble((obj as! DoubleObject).toDouble()))
	}
	if(obj is BooleanObject) {
		return(forBoolean((obj as! BooleanObject).toBoolean()))
	}
	if(obj is CharacterObject) {
		return(forCharacter((obj as! CharacterObject).toCharacter()))
	}
	// FIXME: BufferObject
	var js = JSONEncoder.encode(obj)
	if(js != null) {
		return(js)
	}
	// FIXME: Fall back to platform-specific .toString() or .ToString() methods
	return(null)
}

**
** Converts an integer to a string
**

func asString(value as int) static as string
{
	return(forInteger(value))
}

**
** Converts a double to a string
**

func asString(value as double) static as string
{
	return(forDouble(value))
}

**
** Converts a buffer to a string
**

func asString(value as buffer) static as string
{
	return(forUTF8Buffer(value))
}

**
** Converts a boolean to a string
**

func asString(value as bool) static as string
{
	return(forBoolean(value))
}

**
** Converts a character to a string
**

func asString(value as char) static as string
{
	return(forCharacter(value))
}

**
** Converts a float to a string
**

func asString(value as float) static as string
{
	return(forFloat(value))
}

**
** Checks if a string is empty (ie., either the object is a null pointer or
** the length of the string is less than one character).
**

func isEmpty(str as string) static as bool
{
	if(str == null) {
		return(true)
	}
	if(getLength(str) < 1) {
		return(true)
	}
	return(false)
}

**
** Constructs a new string, given a buffer of bytes and the name of the
** encoding. Supported encodings: UTF8, UCS2 and ASCII
**

func forBuffer(data as buffer, encoding as string) static as string
{
	if(data == null) {
		return(null)
	}
	if(equalsIgnoreCase("UTF8", encoding) || equalsIgnoreCase("UTF-8", encoding)) {
		return(forUTF8Buffer(data))
	}
	if(equalsIgnoreCase("UCS2", encoding) || equalsIgnoreCase("UCS-2", encoding)) {
		return(forUCS2Buffer(data))
	}
	if(equalsIgnoreCase("ASCII", encoding)) {
		return(forASCIIBuffer(data))
	}
	return(null)
}

IFDEF("target_cs") {
	func getDataLength(data as buffer) private static as int
	{
		if(data == null) {
			return(0)
		}
		var v as int
		lang "cs" {{{
			v = data.Length;
			while(v > 0) {
				if(data[v-1] == 0) {
					v--;
				}
				else {
					break;
				}
			}
		}}}
		return(v)
	}
}

**
** Constructs a new string for a buffer of bytes, encoded using the
** ASCII character set.
**

func forASCIIBuffer(data as buffer #used) static as string
{
	if(data == null) {
		return(null)
	}
	IFDEF("target_cs") {
		return(lang "cs" string {{{ System.Text.Encoding.ASCII.GetString(data, 0, getDataLength(data)) }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" string {{{ [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding] }}})
	}
	ELSE IFDEF("target_java") {
		var v as string
		lang "java" {{{
			try {
				v = new java.lang.String(data, "US-ASCII");
			}
			catch(Exception e) {
				System.err.println(e.toString());
			}
		}}}
		return(v)
	}
	ELSE IFDEF("target_js") {
		if(data == null) {
			return(null)
		}
		var sb = new StringBuilder()
		var uintArray as array<uint8>
		lang "js" {{{
			uintArray = new Uint8Array(data);
		}}}
		for(var i = 0; i < SIZE(uintArray); i++) {
			sb.append(lang "js" string {{{ String.fromCharCode(uintArray[i]) }}});
		}
		return(sb.toString())
	}
	ELSE {
		ERROR("Not implemented.")
		return(null)
	}
}

**
** Constructs a new string for a buffer of bytes, encoded using the UTF8
** character encoding.
**

func forUTF8Buffer(data as buffer #used) static as string
{
	if(data == null) {
		return(null)
	}
	IFDEF("target_cs") {
		return(lang "cs" string {{{ System.Text.Encoding.UTF8.GetString(data, 0, getDataLength(data)) }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" string {{{ [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding] }}})
	}
	ELSE IFDEF("target_java") {
		var v as string
		lang "java" {{{
			try {
				v = new java.lang.String(data, "UTF-8");
			}
			catch(Exception e) {
				System.err.println(e.toString());
			}
		}}}
		return(v)
	}
	ELSE IFDEF("target_js") {
		var sb = new StringBuilder()
		var ci = new CharacterIteratorForBuffer(data)
		ci.moveToNextChar()
		loop {
			if(ci.hasEnded()) {
				break
			}
			var c = ci.getCurrentChar()
			sb.append(c)
			ci.moveToNextChar()
		}
		return(sb.toString())
	}
	ELSE {
		ERROR("Not implemented.")
		return(null)
	}
}

**
** Constructs a new string for a buffer of bytes, encoded using the UCS2
** character encoding.
**

func forUCS2Buffer(data as buffer #used) static as string
{
	if(data == null) {
		return(null)
	}
	IFDEF("target_java") {
		var v as string
		lang "java" {{{
			try {
				v = new java.lang.String(data, "UCS-2");
			}
			catch(Exception e) {
				System.err.println(e.toString());
			}
		}}}
		return(v)
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" string {{{ [[NSString alloc] initWithData:data encoding:NSUnicodeStringEncoding] }}})
	}
	ELSE IFDEF("target_js") {
		if(data == null) {
			return(null)
		}
		return(lang "js" string {{{ data.toString("ucs2") }}})
	}
	ELSE {
		ERROR("Not implemented.")
		return(null)
	}
}

**
** Constructs a new string for an array or characters.
**

func forCharArray(chars as char[] #used, offset as int #used, count as int #used) static as string
{
	if(chars == null) {
		return(null)
	}
	IFDEF("target_cs") {
		return(lang "cs" string {{{ new string(chars, offset, count) }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ new java.lang.String(chars, offset, count) }}})
	}
	ELSE IFDEF("target_js") {
		var str as string #used = null
		lang "js" string {{{
			if(offset < chars.length && count <= chars.length && offset < count) {
				str = "";
				for(var ind = offset; ind < count; ind++) {
					str += chars[ind];
				}
			}
		}}}
		return(str)
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

**
** Converts a boolean value to a string. The resulting string will be either
** "true" or "false", depending of the boolean value.
**

func forBoolean(vv as bool) static as string
{
	if(vv == true) {
		return("true")
	}
	return("false")
}

**
** Converts an integer value to a string. The resulting string will be a
** string representation of the value of the integer using the "base-10"
** decimal notation.
**

func forInteger(vv as int #used) static as string
{
	IFDEF("target_cs") {
		return(lang "cs" string {{{ vv.ToString() }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" string {{{ [NSString stringWithFormat:@"%d", vv] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ java.lang.String.valueOf(vv) }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ (~~vv).toString() }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

**
** Converts a long integer value to a string. The resulting string will be a
** string representation of the value of the integer using the "base-10"
** decimal notation.
**

func forLong(vv as long #used) static as string
{
	IFDEF("target_cs") {
		return(lang "cs" string {{{ vv.ToString() }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" string {{{ [NSString stringWithFormat:@"%d", vv] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ java.lang.String.valueOf(vv) }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ vv.toString() }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

**
** Converts an integer value to a string while ensuring that the length of the
** resulting string will reach or exceed the given "length". If the length of the
** string naturally is less than the given length, then "padding" characters will
** be prepended to the string in order to make the string long enough. The default
** padding character is "0", but can be customized with the "paddingString"
** parameter.
**
** eg. String.forIntegerWithPadding(9, 3, "0") would yield "009".
** eg. String.forIntegerWithPadding(10, 4, " ") would yield "  10".
**

func forIntegerWithPadding(vv as int, length as int, paddingString as string = null) static as string
{
	var r = forInteger(vv)
	if(r == null) {
		return(null)
	}
	var ll = getLength(r)
	if(ll >= length) {
		return(r)
	}
	var ps = paddingString
	if(ps == null) {
		ps = "0"
	}
	var sb = new StringBuilder()
	var n as int
	for(n=0; n<length-ll; n++) {
		sb.append(ps)
	}
	sb.append(r)
	return(sb.toString())
}

**
** Converts an integer value to a string using the "base-16" or hexadecimal notation.
**

func forIntegerHex(vv as int #used) static as string
{
	IFDEF("target_cs") {
		return(lang "cs" string {{{ vv.ToString("X") }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" string {{{ [NSString stringWithFormat:@"%X", vv] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ java.lang.Integer.toHexString(vv) }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ (~~vv).toString(16) }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

**
** Converts a character to a string. The result will be a single-character string.
**

func forCharacter(vv as char #used) static as string
{
	IFDEF("target_cs") {
		return(lang "cs" string {{{ new string(vv, 1) }}})
	}
	ELSE IFDEF("target_objc") {
		lang "objc" {{{
			int32_t vvv = (int32_t)htonl(vv);
		}}}
		return(lang "objc" string {{{ [[NSString alloc] initWithBytes:&vvv length:4 encoding:NSUTF32BigEndianStringEncoding] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ java.lang.String.valueOf(vv) }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ vv.toString() }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

**
** Converts a floating point value to a string.
**

func forFloat(vv as float #used) static as string
{
	IFDEF("target_objc") {
		return(lang "objc" string {{{ [NSString stringWithFormat:@"%f", vv] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ java.lang.String.valueOf(vv) }}})
	}
	ELSE IFDEF("target_cs") {
		return(lang "cs" string {{{ vv.ToString() }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ vv.toString() }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

**
** Converts a double-precision floating point value to a string.
**

func forDouble(vv as double #used) static as string
{
	IFDEF("target_objc") {
		return(lang "objc" string {{{ [NSString stringWithFormat:@"%f", vv] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ java.lang.String.valueOf(vv) }}})
	}
	ELSE IFDEF("target_cs") {
		var v as string
		lang "cs" {{{
			v = vv.ToString();
			if(v != null && v.IndexOf('.') < 0) {
				v = v + ".0";
			}
		}}}
		return(v)
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ vv.toString() }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

**
** Converts a string to a buffer of bytes, encoded using the UTF8 encoding.
**

func toUTF8Buffer(str as string) static as buffer
{
	return(toBuffer(str, "UTF8"))
}

**
** Converts a string to a buffer of bytes, encoded using the specified "charset"
** as the character set or encoding. Vaid options for "charset" are platform
** dependent, and would includes values such as UTF8, UTF16, UCS2 and ASCII.
** UTF8 encoding, however, is implemented for all platforms, and is therefore the
** recommended character set to use.
**

func toBuffer(str as string, charset as string) static as buffer
{
	if(str == null || charset == null) {
		return(null)
	}
	IFDEF("target_objc") {
		if(equalsIgnoreCase("UTF8", charset) || equalsIgnoreCase("UTF-8", charset)) {
			var v as buffer
			lang "objc" {{{
				v = [[str dataUsingEncoding:NSUTF8StringEncoding] mutableCopy];
			}}}
			return(v)
		}
	}
	var bytes = getBytesUnsigned(str, charset)
	if(bytes == null) {
		return(null)
	}
	var c = SIZE(bytes)
	var bb = MALLOC(c)
	var n as int
	for(n=0; n<c; n++) {
		Buffer.setByte(bb, n, bytes[n])
	}
	return(bb)
}

func getBytesUnsigned(str as string) private static as uint8[]
{
	return(getBytesUnsigned(str, "UTF-8"))
}

func getBytesUnsigned(str as string #used, charset as string) private static as uint8[]
{
	if(str == null || charset == null) {
		return(null)
	}
	IFDEF("target_cs") {
		var bytes as uint8[]
		lang "cs" {{{
			System.Text.Encoding encoding;
			if("UTF-8".Equals(charset) || "UTF8".Equals(charset)) {
				encoding = System.Text.Encoding.UTF8;
			}
			else if("UTF-16".Equals(charset) || "UTF16".Equals(charset)) {
				encoding = System.Text.Encoding.Unicode;
			}
			else {
				return(null);
			}
			bytes = encoding.GetBytes(str);
		}}}
		return(bytes)
	}
	ELSE IFDEF("target_java") {
		var v as uint8[]
		lang "java" {{{
			try {
				v = str.getBytes(charset);
			}
			catch(Exception e) {
				System.err.println(e.toString());
			}
		}}}
		return(v)
	}
	ELSE IFDEF("target_js") {
		var uintArray as array<uint8>
		lang "js" {{{
			uintArray = new Uint8Array(str.length);
			for(var c = 0; c < str.length; c++) {
				uintArray[c] = str.charCodeAt(c);
			}
		}}}
		return(uintArray)
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

func getBytesSigned(str as string) private static as int8[]
{
	return(getBytesSigned(str, "UTF-8"))
}

func getBytesSigned(str as string #used, charset as string) private static as int8[]
{
	if(str == null || charset == null) {
		return(null)
	}
	IFDEF("target_cs") {
		var bytes as int8[]
		lang "cs" {{{
			var enc = getBytesUnsigned(str, charset);
			if(enc == null) {
				return(null);
			};
			bytes = new sbyte[enc.Length];
			System.Buffer.BlockCopy(enc, 0, bytes, 0, bytes.Length);
		}}}
		return(bytes)
	}
	ELSE IFDEF("target_java") {
		var v as int8[]
		lang "java" {{{
			try {
				v = str.getBytes(charset);
			}
			catch(Exception e) {
				System.err.println(e.toString());
			}
		}}}
		return(v)
	}
	ELSE IFDEF("target_js") {
		var intArray as array<int8>
		lang "js" {{{
			intArray = new Int8Array(str.length);
			for(var c = 0; c < str.length; c++) {
				intArray[c] = str.charCodeAt(c);
			}
		}}}
		return(intArray)
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

**
** Gets the length of a string, representing the number of characters
** composing the string (note: This is not the same as the number of bytes
** allocated to hold the memory for the string).
**

func getLength(str as string #used) static as int
{
	if(str == null) {
		return(0)
	}
	IFDEF("target_cs") {
		return(lang "cs" int {{{ str.Length }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" int {{{ [str length] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" int {{{ str.length() }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" int {{{ str.length }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(-1)
	}
}

**
** Appends a string "str2" to the end of another string "str1". Either one
** of the values may be null: If "str1" is null, the value of "str2" is returned,
** and if "str2" is null, the value of "str1" is returned.
**

func append(str1 as string #used, str2 as string #used) static as string
{
	if(str1 == null) {
		return(str2)
	}
	if(str2 == null) {
		return(str1)
	}
	IFDEF("target_cs") {
		return(lang "cs" string {{{ System.String.Concat(str1, str2) }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" string {{{ [str1 stringByAppendingString:str2] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ str1.concat(str2 != null ? str2 : "") }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ str1.concat(str2) }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(str1)
	}
}

**
** Appends an integer value "intvalue" to the end of string "str". If the
** original string is null, then a new string is returned, representing only
** the integer value.
**

func append(str as string, intvalue as int) static as string
{
	return(append(str, forInteger(intvalue)))
}

**
** Appends a character value "charvalue" to the end of string "str". If the
** original string is null, then a new string is returned, representing only
** the character value.
**

func append(str as string, charvalue as char) static as string
{
	return(append(str, forCharacter(charvalue)))
}

**
** Appends a floating point value "floatvalue" to the end of string "str". If the
** original string is null, then a new string is returned, representing only
** the floating point value.
**

func append(str as string, floatvalue as float) static as string
{
	return(append(str, forFloat(floatvalue)))
}

**
** Appends a double-precision floating point value "doublevalue" to the end of
** string "str". If the original string is null, then a new string is returned,
** representing only the floating point value.
**

func append(str as string, doublevalue as double) static as string
{
	return(append(str, forDouble(doublevalue)))
}

**
** Appends a boolean value "boolvalue" to the end of string "str". If the
** original string is null, then a new string is returned, representing only
** the boolean value.
**

func append(str as string, boolvalue as bool) static as string
{
	return(append(str, forBoolean(boolvalue)))
}

**
** Converts all characters of a string to lowercase.
**

func toLowerCase(str as string #used) static as string
{
	if(str == null) {
		return(null)
	}
	IFDEF("target_cs") {
		return(lang "cs" string {{{ str.ToLower() }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" string {{{ [str lowercaseString] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ str.toLowerCase() }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ str.toLowerCase() }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(str)
	}
}

**
** Converts all characters of a string to uppercase.
**

func toUpperCase(str as string #used) static as string
{
	if(str == null) {
		return(null)
	}
	IFDEF("target_cs") {
		return(lang "cs" string {{{ str.ToUpper() }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" string {{{ [str uppercaseString] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ str.toUpperCase() }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ str.toUpperCase() }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(str)
	}
}

**
** Gets a character with the specified index "index" from the given string.
** This method is deprecated: Use getChar() instead.
**

func charAt(str as string, index as int) static as char #deprecated
{
	return(getChar(str, index))
}

**
** Gets a character with the specified index "index" from the given string.
**

func getChar(str as string #used, index as int #used) static as char
{
	if(str == null) {
		return(0 as char)
	}
	IFDEF("target_cs") {
		return(lang "cs" char {{{ str == null || index < 0 || index >= str.Length ? (char)0 : str[index] }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" char {{{ str == nil || index < 0 || index >= [str length] ? 0 : [str characterAtIndex:index] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" char {{{ str == null || index < 0 || index >= str.length() ? (char)0 : str.charAt(index) }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" char {{{ str == null || index < 0 || index >= str.length ? 0 : str[index] }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(0 as char)
	}
}

**
** Compares two strings, and returns true if both strings contain exactly
** the same contents (even though they may be represented by different objects).
** Either of the strings may be null, in which case the comparison always results
** to false.
**

func equals(str1 as string #used, str2 as string #used) static as bool
{
	if(str1 == null || str2 == null) {
		return(false) // FIXME: Could be a more meaningful comparison
	}
	IFDEF("target_cs") {
		return(lang "cs" bool {{{ str1.Equals(str2) }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" bool {{{ [str1 isEqualToString:str2] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" bool {{{ str1.equals(str2) }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" bool {{{ str1 === str2 }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(false)
	}
}

**
** Compares two strings for equality (like equals()) while considering uppercase
** and lowercase versions of the same character as equivalent. Eg. strings
** "ThisIsAString" and "thisisastring" would be considered equivalent, and the
** result of comparison would be "true".
**

func equalsIgnoreCase(str1 as string #used, str2 as string #used) static as bool
{
	if(str1 == null || str2 == null) {
		return(false) // FIXME: Could be a more meaningful comparison
	}
	IFDEF("target_cs") {
		return(lang "cs" bool {{{ System.String.Compare(str1, str2, true) == 0 }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" bool {{{ [str1 caseInsensitiveCompare:str2] == NSOrderedSame }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" bool {{{ str1.equalsIgnoreCase(str2) }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" bool {{{
			str1.toLowerCase() === str2.toLowerCase()
		}}})
	}
	ELSE {
		ERROR("Not implemented")
		return(false)
	}
}

**
** Compares two strings, and returns an integer value representing their
** sorting order. The return value 0 indicates that the two strings are 
** equivalent. A negative return value (< 0) indicates that "str1" is
** less than "str2", and a positive return value (> 0) indicates that "str1"
** is greater than "str2". If either "str1" or "str2" is null, the comparison
** yields the value 0.
**

func compare(str1 as string #used, str2 as string #used) static as int
{
	if(str1 == null || str2 == null) {
		return(0) // FIXME: Could be a more meaningful comparison
	}
	IFDEF("target_cs") {
		return(lang "cs" int {{{ System.String.Compare(str1, str2, false) }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" int {{{ str1.compareTo(str2) }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" int {{{ ({ NSComparisonResult _r = [str1 compare:str2]; _r == NSOrderedAscending ? -1 : (_r == NSOrderedSame ? 0 : 1); }) }}})
	}
	ELSE IFDEF ("target_js") {
		return(lang "js" int {{{ str1.localeCompare(str2) }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(0)
	}
}

**
** Compares strings exactly like compareTo(), but this method considers uppercase
** and lowercase versions of each character as equivalent.
**

func compareToIgnoreCase(str1 as string #used, str2 as string #used) static as int
{
	if(str1 == null || str2 == null) {
		return(0) // FIXME: Could be a more meaningful comparison
	}
	IFDEF("target_cs") {
		return(lang "cs" int {{{ System.String.Compare(str1, str2, true) }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" int {{{ str1.compareToIgnoreCase(str2) }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" int {{{ ({ NSComparisonResult _r = [str1 caseInsensitiveCompare:str2]; _r == NSOrderedAscending ? -1 : (_r == NSOrderedSame ? 0 : 1); }) }}})
	}
	ELSE IFDEF("target_js") {
		return (lang "js" int {{{
			str1.toLowerCase().localeCompare(str2.toLowerCase())
		}}})
	}
	ELSE {
		ERROR("Not implemented")
		return(0)
	}
}

**
** Gets a hash code version of the string as an integer.
**

func getHashCode(str as string #used) static as int
{
	if(str == null) {
		return(0)
	}
	IFDEF("target_cs") {
		return(lang "cs" int {{{ str.GetHashCode() }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" int {{{ [str hash] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" int {{{ str.hashCode() }}})
	}
	ELSE IFDEF("target_js") {
		var hash #used = 0
		lang "js" {{{
			if(str != null) {
				for(var i = 0; i < str.length; i++) {
					var ch = str.charCodeAt(i);
					hash = ((hash << 5) - hash) + ch;
					hash = hash & hash;
				}
			}
		}}}
		return(hash)
	}
	ELSE {
		ERROR("Not implemented")
		return(0)
	}
}

**
** Gets the first index of a given character "c" in string "str", starting from
** index "start". This method is deprecated, use getIndexOf() instead.
**

func indexOf(str as string, c as char, start as int = 0) static as int #deprecated
{
	return(getIndexOf(str, c, start))
}

**
** Gets the first index of a given character "c" in string "str", starting from
** index "start".
**

func getIndexOf(str as string #used, c as char #used, start as int #used = 0) static as int
{
	if(str == null) {
		return(-1)
	}
	IFDEF("target_cs") {
		return(lang "cs" int {{{ str.IndexOf(c, start) }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" int {{{ str.indexOf((int)c, start) }}})
	}
	ELSE IFDEF("target_objc") {
		var v as int
		lang "objc" {{{
			NSRange r = [str rangeOfCharacterFromSet:[NSCharacterSet characterSetWithCharactersInString:[NSString stringWithFormat:@"%c", c]] options:0 range:NSMakeRange(start, [str length]-start)];
			if(r.location == NSNotFound) {
				v = -1;
			}
			else {
				v = r.location;
			}
		}}}
		return(v)
	}
	ELSE IFDEF("target_js") {
		return(lang "js" int {{{ str.indexOf(c, start) }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(-1)
	}
}

**
** Gets the first index of a given substring "s" in string "str", starting from
** index "start". This method is deprecated, use getIndexOf() instead.
**

func indexOf(str as string, s as string, start as int = 0) static as int #deprecated
{
	return(getIndexOf(str, s, start))
}

**
** Gets the first index of a given substring "s" in string "str", starting from
** index "start".
**

func getIndexOf(str as string #used, s as string #used, start as int #used = 0) static as int
{
	if(str == null) {
		return(-1)
	}
	IFDEF("target_cs") {
		return(lang "cs" int {{{ str.IndexOf(s, start) }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" int {{{ str.indexOf(s, start) }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" int {{{
			[str rangeOfString:s options:0 range:NSMakeRange(start, [str length]-start)].location
		}}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" int {{{ str.indexOf(s, start) }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(-1)
	}
}

**
** Gets the last index of a given character "c" in string "str", starting from
** index "start". This method is deprecated, use getLastIndexOf() instead.
**

func lastIndexOf(str as string, c as char, start as int = -1) static as int #deprecated
{
	return(getLastIndexOf(str, c, start))
}

**
** Gets the last index of a given character "c" in string "str", starting from
** index "start".
**

func getLastIndexOf(str as string #used, c as char #used, start as int #used = -1) static as int
{
	if(str == null) {
		return(-1)
	}
	IFDEF("target_cs") {
		if(start < 0) {
			return(lang "cs" int {{{ str.LastIndexOf(c) }}})
		}
		return(lang "cs" int {{{ str.LastIndexOf(c, start) }}})
	}
	ELSE IFDEF("target_java") {
		if(start < 0) {
			return(lang "java" int {{{ str.lastIndexOf((int)c) }}})
		}
		return(lang "java" int {{{ str.lastIndexOf((int)c, start) }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" int {{{
			[str rangeOfCharacterFromSet:[NSCharacterSet characterSetWithCharactersInString:[NSString stringWithFormat:@"%c", c]] options:NSBackwardsSearch range:NSMakeRange(0, start < 0 ? [str length] : start)].location
		}}})
	}
	ELSE IFDEF("target_js") {
		if(start <= 0) {
			return(lang "js" int {{{ str.lastIndexOf(c) }}})
		}
		return(lang "js" int {{{ str.lastIndexOf(c, start) }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(-1)
	}
}

**
** Gets the last index of a given substring "s" in string "str", starting from
** index "start". This method is deprecated, use getLastIndexOf() instead.
**

func lastIndexOf(str as string, s as string, start as int = -1) static as int #deprecated
{
	return(getLastIndexOf(str, s, start))
}

**
** Gets the last index of a given substring "s" in string "str", starting from
** index "start".
**

func getLastIndexOf(str as string #used, s as string #used, start as int #used = -1) static as int
{
	if(str == null) {
		return(-1)
	}
	IFDEF("target_cs") {
		if(start < 0) {
			return(lang "cs" int {{{ str.LastIndexOf(s) }}})
		}
		return(lang "cs" int {{{ str.LastIndexOf(s, start) }}})
	}
	ELSE IFDEF("target_java") {
		if(start < 0) {
			return(lang "java" int {{{ str.lastIndexOf(s) }}})
		}
		return(lang "java" int {{{ str.lastIndexOf(s, start) }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" int {{{
			[str rangeOfString:s options:NSBackwardsSearch range:NSMakeRange(0, start < 0 ? [str length] : start)].location
		}}})
	}
	ELSE IFDEF("target_js") {
		if(start <= 0) {
			return(lang "js" int {{{ str.lastIndexOf(s) }}})
		}
		return(lang "js" int {{{ str.lastIndexOf(s, start) }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(-1)
	}
}

**
** Gets a substring of "str", starting from index "start". This method is
** deprecated, use getSubString() instead.
**

func subString(str as string, start as int) static as string #deprecated
{
	return(getSubString(str, start))
}

**
** Gets a substring of "str", starting from index "start".
**

func getSubString(str as string #used, start as int #used) static as string
{
	if(str == null) {
		return(null)
	}
	if(start >= getLength(str)) {
		return("")
	}
	var ss = start
	if(ss < 0) {
		ss = 0
	}
	IFDEF("target_cs") {
		return(lang "cs" string {{{ str.Substring(ss) }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ str.substring(ss) }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" string {{{ [str substringFromIndex:ss] }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ str.substring(ss) }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(str)
	}
}

**
** Gets a substring of "str", starting from index "start" and with a maximum
** length of "length". This method is deprecated, use getSubString() instead.
**

func subString(str as string, start as int, length as int) static as string #deprecated
{
	return(getSubString(str, start, length))
}

**
** Gets a substring of "str", starting from index "start" and with a maximum
** length of "length".
**

func getSubString(str as string #used, start as int #used, length as int #used) static as string
{
	if(str == null) {
		return(null)
	}
	var strl = getLength(str)
	if(start >= strl) {
		return("")
	}
	var ss = start
	if(ss < 0) {
		ss = 0
	}
	var ll = length
	if(ll > strl - start) {
		ll = strl - start
	}
	IFDEF("target_cs") {
		return(lang "cs" string {{{ str.Substring(ss, ll)  }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" string {{{ [str substringWithRange:NSMakeRange(ss, ll)] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ str.substring(ss, ss+ll) }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ str.substring(ss, ss+ll) }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(str)
	}
}

**
** Checks is the string "str1" contains a substring "str2". Returns true
** if the substring is found.
**

func contains(str1 as string, str2 as string) static as bool
{
	if(str1 == null || str2 == null) {
		return(false)
	}
	IFDEF("target_cs") {
		return(lang "cs" bool {{{ str1.Contains(str2)  }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" bool {{{ [str1 containsString:str2] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" bool {{{ str1.contains(str2)  }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" bool {{{ str1.includes(str2) }}})
	}
	ELSE {
		ERROR("Not implemented")
		return(false)
	}
}

**
** Checks if the string "str1" starts with the complete contents of "str2".
** If the "offset" parameter is supplied an is greater than zero, the checking
** does not start from the beginning of "str1" but from the given character index.
**

func startsWith(str1 as string, str2 as string #used, offset as int = 0) static as bool
{
	if(str1 == null || str2 == null) {
		return(false)
	}
	var nstr as string #used
	if(offset > 0) {
		nstr = getSubString(str1, offset)
	}
	else {
		nstr = str1
	}
	IFDEF("target_cs") {
		return(lang "cs" bool {{{ nstr.StartsWith(str2) }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" bool {{{ [nstr hasPrefix:str2] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" bool {{{ nstr.startsWith(str2) }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" bool {{{ nstr.startsWith(str2) }}})
	}
	ELSE {
		ERROR("Not Implemented")
		return(false)
	}
}

**
** Checks if the string "str1" ends with the complete contents of "str2".
**

func endsWith(str1 as string #used, str2 as string #used) static as bool
{
	if(str1 == null || str2 == null) {
		return(false)
	}
	IFDEF("target_cs") {
		return(lang "cs" bool {{{ str1.EndsWith(str2) }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" bool {{{ [str1 hasSuffix:str2] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" bool {{{ str1.endsWith(str2) }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" bool {{{ str1.endsWith(str2) }}})
	}
	ELSE {
		ERROR("Not Implemented")
		return(false)
	}
}

**
** Strips (or trims) the given string "str" by removing all blank characters
** from both ends (the beginning and the end) of the string.
**

func strip(str as string #used) static as string
{
	if(str == null) {
		return(null)
	}
	IFDEF("target_cs") {
		return(lang "cs" string {{{ str.Trim() }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ str.trim() }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ str.trim() }}})
	}
	ELSE {
		ERROR("Not Implemented")
		return(null)
	}
}

**
** Replaces all instances of "oldChar" with the value of "newChar" in the given
** string "str". The return value is a new string where the changes have been
** effected. The original string remains unchanged.
**

func replace(str as string #used, oldChar as char #used, newChar as char #used) static as string
{
	if(str == null) {
		return(null)
	}
	IFDEF("target_cs") {
		return(lang "cs" string {{{ str.Replace(oldChar, newChar) }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ str.replace(oldChar, newChar) }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ str.replace(oldChar, newChar) }}})
	}
	ELSE {
		ERROR("Not Implemented")
		return(null)
	}
}

**
** Replaces all instances of the substring "target" with the value of "replacement"
** in the given string "str". The return value is a new string where the changes
** have been effected. The original string remains unchanged.
**

func replace(str as string #used, target as string #used, replacement as string #used) static as string
{
	if(str == null) {
		return(null)
	}
	IFDEF("target_cs") {
		return(lang "cs" string {{{ str.Replace(target, replacement) }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ str.replace(target, replacement) }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ str.replace(target, replacement) }}})
	}
	ELSE {
		ERROR("Not Implemented")
		return(null)
	}
}

**
** Converts the string "str" to an array of characters.
**

func toCharArray(str as string #used) static as char[]
{
	if(str == null) {
		return(null)
	}
	IFDEF("target_cs") {
		return(lang "cs" char[] {{{ str.ToCharArray() }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" char[] {{{ str.toCharArray() }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" char[] {{{ str }}})
	}
	ELSE {
		ERROR("Not Implemented")
		return(null)
	}
}

**
** Splits the string "str" to a vector of strings, cutting the original string
** at each instance of the character "delim". If the value of "max" is supplied
** and is given a value greater than 0, then the resulting vector will only have
** a maximum of "max" entries. If the delimiter character appears beyond the
** maximum entries, the last entry in the vector will be the complete remainder
** of the original string, including the remaining delimiter characters.
**

func split(str as string, delim as char, max as int = 0) static as vector<string>
{
	var v = new vector<string>
	if(str == null) {
		return(v)
	}
	var n = 0
	while(true) {
		if(max > 0 && Vector.getSize(v) >= max - 1) {
			Vector.append(v, subString(str, n))
			break
		}
		var x = indexOf(str, delim, n)
		if(x < 0) {
			Vector.append(v, subString(str, n))
			break
		}
		Vector.append(v, subString(str, n, x - n))
		n = x + 1
	}
	return(v)
}

**
** Checks if the given string is fully an integer (no other characters
** appear in the string).
**

func isInteger(str as string) static as bool
{
	if(str == null) {
		return(false)
	}
	var it = iterate(str)
	if(it == null) {
		return(false)
	}
	loop {
		var c = it.getNextChar()
		if(c < 1) {
			break
		}
		if(c < '0' || c > '9') {
			return(false)
		}
	}
	return(true)
}

**
** Converts the string to an integer. If the string does not represent a valid
** integer, than the value "0" is returned.
**
** Eg. toInteger("99") = 99
** Eg. toInteger("asdf") = 0
**

func toInteger(str as string) static as int
{
	if(isEmpty(str)) {
		return(0)
	}
	var v = 0
	var m = getLength(str)
	var n as int
	for(n = 0; n < m; n++) {
		var c = charAt(str, n)
		if(c >= '0' && c <= '9') {
			v = v * 10
			v += (c - '0') as int
		}
		else {
			break
		}
	}
	return(v)
}

**
** Converts the string to a long integer. If the string does not represent a valid
** integer, than the value "0" is returned.
**
** Eg. toLong("99") = 99
** Eg. toLong("asdf") = 0
**

func toLong(str as string) static as long
{
	if(isEmpty(str)) {
		return(0)
	}
	var v = 0 as long
	var m = getLength(str)
	var n as int
	for(n = 0; n < m; n++) {
		var c = charAt(str, n)
		if(c >= '0' && c <= '9') {
			v = v * 10
			v += (c - '0') as long
		}
		else {
			break
		}
	}
	return(v)
}

**
** Converts the string to an integer, while treating the string as a hexadecimal
** representation of a number, eg. toIntegerFromHex("a") = 10
**

func toIntegerFromHex(str as string) static as int
{
	if(isEmpty(str)) {
		return(0)
	}
	var v = 0
	var m = getLength(str)
	var n as int
	for(n = 0; n < m; n++) {
		var c = charAt(str, n)
		if(c >= '0' && c <= '9') {
			v = v * 16
			v += (c - '0') as int
		}
		else if(c >= 'a' && c <= 'f') {
			v = v * 16
			v += (10 + c - 'a') as int
		}
		else if(c >= 'A' && c <= 'F') {
			v = v * 16
			v += (10 + c - 'A') as int
		}
		else {
			break
		}
	}
	return(v)
}

**
** Converts the string to a double-precision floating point number. If the
** string does not contain a valid representation of a floating point number,
** then the value "0.0" is returned.
**

func toDouble(str as string #used) static as double
{
	if(str == null) {
		return(0.0)
	}
	IFDEF("target_objc") {
		return(lang "objc" double {{{ [str doubleValue] }}})
	}
	ELSE IFDEF("target_cs") {
		var v = 0.0
		lang "cs" {{{
			try {
				v = System.Double.Parse(str);
			}
			catch {
				v = 0.0;
			}
		}}}
		return(v)
	}
	ELSE IFDEF("target_java") {
		var v = 0.0
		lang "Java" {{{
			try {
				if(str != null) {
					v = java.lang.Double.parseDouble(str);
				}
			}
			catch(Exception e) {
				v = 0.0;
			}
		}}}
		return(v)
	}
	ELSE IFDEF("target_js") {
		var v as double #used
		lang "js" {{{
			v = parseFloat(str);
			if (isNaN(v)) {
				v =  0.0;
			}
		}}}
		return(v)
	}
	ELSE {
		ERROR("Not Implemented")
		return(0.0)
	}
}

**
** Iterates the string "string" character by character by using an
** instance of CharacterIterator.
**

func iterate(string as string) static as CharacterIterator
{
	return(new CharacterIteratorForString(string))
}

**
** Creates a new string that contains the same contents as "string", but with
** all characters appearing in reverse order.
**

func reverse(string as string) static as string
{
	if(string == null) {
		return(null)
	}
	var sb = new StringBuilder()
	var it = iterate(string)
	var c as char
	while((c = it.getNextChar()) > 0) {
		sb.insert(0, c)
	}
	return(sb.toString())
}

**
** Iterates the string "string" in reverse order (starting from the end, moving
** towards the beginning).
**

func iterateReverse(string as string) static as CharacterIterator
{
	return(iterate(reverse(string)))
}

**
** Creates a new string based on "string" that is at least "length" characters
** long. If the original string is shorter, it will be padded to the desired length
** by adding instances of paddingCharacter (default of which is the space character).
** The "aling" attribute may be either -1, 0 or 1, and determines if the padding
** characters willb e added to the end, both sides or to the beginning, respectively.
**

func padToLength(string as string, length as int, align as int = -1, paddingCharacter as char = ' ') static as string
{
	var ll as int
	if(string == null) {
		ll = 0
	}
	else {
		ll = getLength(string)
	}
	if(ll >= length) {
		return(string)
	}
	var add = length - ll
	var n = 0
	var sb = new StringBuilder()
	if(align < 0) {
		sb.append(string)
		for(n=0; n<add; n++) {
			sb.append(paddingCharacter)
		}
	}
	else if(align > 0) {
		var ff = add / 2
		var ss = add - ff
		for(n=0; n<ff; n++) {
			sb.append(paddingCharacter)
		}
		sb.append(string)
		for(n=0; n<ss; n++) {
			sb.append(paddingCharacter)
		}
	}
	else {
		for(n=0; n<add; n++) {
			sb.append(paddingCharacter)
		}
		sb.append(string)
	}
	return(sb.toString())
}

**
** Splits the given string "str" to a vector of multiple strings, cutting the
** string at each instance of the "delim" character where the delim does not
** appear enclosed in either double quotes or single quotes.
**
** Eg. quotedStringToVector("first 'second third'", ' ') => [ "first", "second third" ]
**

func quotedStringToVector(str as string, delim as char) static as vector<string>
{
	var v = new vector<string>
	if(str == null) {
		return(v)
	}
	var dquote = false
	var quote = false
	var sb as StringBuilder = null
	var c as char
	var it = iterate(str)
	while((c = it.getNextChar()) > 0) {
		if(c == '"' && quote == false) {
			dquote = !dquote
		}
		else if(c == '\'' && dquote == false) {
			quote = !quote
		}
		else if(quote == false && dquote == false && c == delim) {
			if(sb != null) {
				var r = sb.toString()
				if(r == null) {
					r = ""
				}
				v += r
			}
			sb = null
		}
		else {
			if(sb == null) {
				sb = new StringBuilder()
			}
			sb.append(c)
		}
		if((quote == true || dquote == true) && sb == null) {
			sb = new StringBuilder()
		}
	}
	if(sb != null) {
		var r = sb.toString()
		if(r == null) {
			r = ""
		}
		v += r
	}
	return(v)
}

**
** Parses the string "str", splitting it to multiple strings using quotedStringToVector(),
** and then further processing it to key/value pairs, splitting each string at the
** equal sign '=' and adding the entries to a map.
**

func quotedStringToMap(str as string, delim as char) static as map<string,string>
{
	var v = new map<string,string>
	var vector = quotedStringToVector(str, delim)
	foreach(c in vector) {
		var sp = split(c, '=', 2)
		var key = sp[0]
		var val = sp[1]
		if(isEmpty(key) == false) {
			v[key] = val
		}
	}
	return(v)
}

**
** Combines a vector of strings to a single string, incorporating the "delim"
** character between each string in the vector. If the "unique" variable is set to
** "true", only one instance of each unique string will be appended to the resulting
** string.
**

func combine(strings as vector<string>, delim as char, unique as bool = false) static as string
{
	var sb = new StringBuilder()
	var flags as map<string,string>
	if(unique) {
		flags = new map<string,string>
	}
	foreach(o as string in strings) {
		if(o == null) {
			continue
		}
		if(flags != null) {
			if(Map.get(flags, o) != null) {
				continue
			}
			Map.set(flags, o, "true")
		}
		if(delim > 0 && sb.count() > 0) {
			sb.append(delim)
		}
		sb.append(o)
	}
	return(sb.toString())
}