/*
 * This file is part of Jkop
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

**
** The String class provides all the common string manipulation functions,
** including comparisons, concatenation, transformations to upper and lowercase,
** getting substrings, finding characters or substrings, splitting the strings,
** converting to byte buffers, etc.
**

class:

**
** Converts an arbitrary object to a string, if possible.
**

func asString(obj as object) static as string
{
	assert obj
	if obj is string:
		return obj as! string
	if obj is StringObject:
		return((obj as! StringObject).toString())
	if obj is IntegerObject:
		return forInteger((obj as! IntegerObject).toInteger())
	if obj is LongIntegerObject:
		return forLongInteger((obj as! LongIntegerObject).toLong())
	if obj is DoubleObject:
		return forDouble((obj as! DoubleObject).toDouble())
	if obj is BooleanObject:
		return forBoolean((obj as! BooleanObject).toBoolean())
	if obj is CharacterObject:
		return forCharacter((obj as! CharacterObject).toCharacter())
	if obj is buffer:
		return forBufferHex(obj as! buffer)
	if obj is BufferObject {
		var v = (obj as! BufferObject).toBuffer()
		if not v:
			return ""
		return forBufferHex(v)
	}
	var js = JSONEncoder.encode(obj)
	if js:
		return js
	// FIXME: Fall back to platform-specific .toString() or .ToString() methods
	return null
}

**
** Returns a safe string (= make sure it is not null). Essentially returns a valid
** non-null empty string if the value is null. Otherwise returns the string itself.
**

func safeString(str as string) static as string
{
	if not str:
		return ""
	return str
}

**
** Converts an integer to a string
**

func asString(value as int) static as string:
	return forInteger(value)

**
** Converts a double to a string
**

func asString(value as double) static as string:
	return forDouble(value)

**
** Converts a buffer to a string
**

func asString(value as buffer) static as string:
	return forUTF8Buffer(value)

**
** Converts a boolean to a string
**

func asString(value as bool) static as string:
	return forBoolean(value)

**
** Converts a character to a string
**

func asString(value as char) static as string:
	return forCharacter(value)

**
** Converts a float to a string
**

func asString(value as float) static as string:
	return forFloat(value)

**
** Checks if a string is empty (ie., either the object is a null pointer or
** the length of the string is less than one character).
**

func isEmpty(str as string) static as bool
{
	if not str:
		return true
	if getLength(str) < 1:
		return true
	return false
}

**
** Checks that the given string is not empty. Returns true if the string is not
** empty, false if the string is empty.
**

func isNotEmpty(str as string) static as bool:
	return not isEmpty(str)

**
** Constructs a new string, given a buffer of bytes and the name of the
** encoding. Supported encodings: UTF8, UCS2 and ASCII
**

func forBuffer(data as buffer, encoding as string) static as string
{
	assert data
	if equalsIgnoreCase("UTF8", encoding) || equalsIgnoreCase("UTF-8", encoding):
		return forUTF8Buffer(data)
	if equalsIgnoreCase("UCS2", encoding) || equalsIgnoreCase("UCS-2", encoding):
		return forUCS2Buffer(data)
	if equalsIgnoreCase("ASCII", encoding):
		return forASCIIBuffer(data)
	return null
}

IFDEF("target_cs") {
	func getDataLength(data as buffer) private static as int
	{
		if data == null:
			return 0
		var v as int
		lang "cs" {{{
			v = data.Length;
			while(v > 0) {
				if(data[v-1] == 0) {
					v--;
				}
				else {
					break;
				}
			}
		}}}
		return v
	}
}

**
** Constructs a new string for a buffer of bytes, encoded using the
** ASCII character set.
**

func forASCIIBuffer(data as buffer #used) static as string
{
	assert data
	IFDEF "target_cs" {
		return lang "cs" string {{{ System.Text.Encoding.ASCII.GetString(data, 0, getDataLength(data)) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" string {{{ [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding] }}}
	}
	ELSE IFDEF "target_java" {
		var v as string
		lang "java" {{{
			try {
				v = new java.lang.String(data, "US-ASCII");
			}
			catch(java.lang.Exception e) {
				System.err.println(e.toString());
			}
		}}}
		return v
	}
	ELSE IFDEF "target_js" {
		var sb = new StringBuilder()
		var uintArray as array<uint8>
		lang "js" {{{
			uintArray = new Uint8Array(data);
		}}}
		for(var i = 0; i < SIZE(uintArray); i++):
			sb.append(lang "js" string {{{ String.fromCharCode(uintArray[i]) }}})
		return sb.toString()
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ data!!.toByteArray()?.toString(kotlin.text.Charsets.US_ASCII) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" string {{{ Swift.String(data: data! as Foundation.Data, encoding: Swift.String.Encoding.ascii) }}}
	}
	ELSE {
		ERROR "Not implemented."
		return null
	}
}

**
** Constructs a new string for a buffer of bytes, encoded using the UTF8
** character encoding.
**

func forUTF8Buffer(data as buffer #used) static as string
{
	assert data
	IFDEF "target_cs" {
		return lang "cs" string {{{ System.Text.Encoding.UTF8.GetString(data, 0, getDataLength(data)) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" string {{{ [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding] }}}
	}
	ELSE IFDEF "target_java" {
		var v as string
		lang "java" {{{
			try {
				v = new java.lang.String(data, "UTF-8");
			}
			catch(java.lang.Exception e) {
				System.err.println(e.toString());
			}
		}}}
		return v
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ kotlin.text.String(data!!.toByteArray(), kotlin.text.Charsets.UTF_8) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" string {{{ Swift.String(data: data! as Foundation.Data, encoding: Swift.String.Encoding.utf8) }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" string {{{ _sushi.convertBufferToString(data) }}}
	}
	ELSE {
		var sb = new StringBuilder()
		var ci = CharacterIteratorForBuffer.forBuffer(data)
		ci.moveToNextChar()
		loop {
			if ci.hasEnded():
				break
			var c = ci.getCurrentChar()
			sb.append(c)
			ci.moveToNextChar()
		}
		return sb.toString()
	}
}

**
** Constructs a new string for a buffer of bytes, encoded using the UCS2
** character encoding.
**

func forUCS2Buffer(data as buffer #used) static as string
{
	if(data == null) {
		return(null)
	}
	IFDEF("target_java") {
		var v as string
		lang "java" {{{
			try {
				v = new java.lang.String(data, "UCS-2");
			}
			catch(java.lang.Exception e) {
				System.err.println(e.toString());
			}
		}}}
		return(v)
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" string {{{ [[NSString alloc] initWithData:data encoding:NSUnicodeStringEncoding] }}})
	}
	ELSE IFDEF("target_js") {
		if(data == null) {
			return(null)
		}
		return(lang "js" string {{{ data.toString("ucs2") }}})
	}
	ELSE IFDEF("target_swift") {
		return lang "swift" string {{{ Swift.String(data: data! as Foundation.Data, encoding: Swift.String.Encoding.unicode) }}}
	}
	ELSE {
		ERROR("Not implemented.")
		return(null)
	}
}

**
** Constructs a new string for an array or characters.
**

func forCharArray(chars as char[] #used, offset as int #used, count as int #used) static as string
{
	assert chars
	IFDEF "target_cs" {
		return lang "cs" string {{{ new string(chars, offset, count) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" string {{{ new java.lang.String(chars, offset, count) }}}
	}
	ELSE IFDEF "target_js" {
		var str as string #used = null
		lang "js" string {{{
			if(offset < chars.length && count <= chars.length && offset < count) {
				str = "";
				for(var ind = offset; ind < count; ind++) {
					str += chars[ind];
				}
			}
		}}}
		return str
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ kotlin.text.String(chars, offset, count) }}}
	}
	ELSE {
		var sb = new StringBuilder()
		var sz = SIZE chars
		for(var n=0; n<count && n+offset<sz; n++):
			sb.append(chars[n+offset])
		return sb.toString()
	}
}

**
** Converts a boolean value to a string. The resulting string will be either
** "true" or "false", depending of the boolean value.
**

func forBoolean(vv as bool) static as string
{
	if vv == true:
		return "true"
	return "false"
}

**
** Converts an integer value to a string. The resulting string will be a
** string representation of the value of the integer using the "base-10"
** decimal notation.
**

func forInteger(vv as int #used) static as string
{
	IFDEF("target_cs") {
		return(lang "cs" string {{{ vv.ToString() }}})
	}
	ELSE IFDEF("target_objc") {
		return(lang "objc" string {{{ [NSString stringWithFormat:@"%d", vv] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ java.lang.String.valueOf(vv) }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ (~~vv).toString() }}})
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ vv.toString() }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" string {{{ _sushi.createStringForInteger(vv) }}}
	}
	ELSE IFDEF "target_stdlua" {
		return lang "lua" string {{{ tostring(vv) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" string {{{ vv.description }}}
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

**
** Converts a long integer value to a string. The resulting string will be a
** string representation of the value of the integer using the "base-10"
** decimal notation.
**

func forLongInteger(vv as long #used) static as string
{
	IFDEF "target_cs" {
		return lang "cs" string {{{ vv.ToString() }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" string {{{ [NSString stringWithFormat:@"%d", vv] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" string {{{ java.lang.String.valueOf(vv) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" string {{{ (~~vv).toString() }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ vv.toString() }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" string {{{ _sushi.createStringForInteger(vv) }}}
	}
	ELSE IFDEF "target_stdlua" {
		return lang "lua" string {{{ tostring(vv) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" string {{{ vv.description }}}
	}
	ELSE {
		ERROR "Not implemented"
		return null
	}
}

**
** Takes a string that represents a number, and presents it in a nicely
** formatted manner, with delimiter separating each sequence of three digits.
**

func formatNumberString(vv as string, delimiter as char) static as string
{
	assert vv
	var it = assert iterate(vv)
	var rr = getLength(vv)
	var sb = new StringBuilder()
	loop {
		var c = it.getNextChar()
		if c < 1:
			break
		sb.append(c)
		rr --
		if rr < 1:
			break
		if rr % 3 == 0:
			sb.append(delimiter)
	}
	return sb.toString()
}

**
** Converts an integer value to a string and presents it in a nicely
** formatted manner, with delimiter separating each sequence of three digits.
**

func formatInteger(vv as int, delimiter as char) static as string:
	return formatNumberString(forInteger(vv), delimiter)

**
** Converts a long integer value to a string and presents it in a nicely
** formatted manner, with delimiter separating each sequence of three digits.
**

func formatLongInteger(vv as int, delimiter as char) static as string:
	return formatNumberString(forLongInteger(vv), delimiter)

**
** Converts an integer value to a string while ensuring that the length of the
** resulting string will reach or exceed the given "length". If the length of the
** string naturally is less than the given length, then "padding" characters will
** be prepended to the string in order to make the string long enough. The default
** padding character is "0", but can be customized with the "paddingString"
** parameter.
**
** eg. String.forIntegerWithPadding(9, 3, "0") would yield "009".
** eg. String.forIntegerWithPadding(10, 4, " ") would yield "  10".
**

func forIntegerWithPadding(vv as int, length as int, paddingString as string = null) static as string
{
	var r = assert forInteger(vv)
	var ll = getLength(r)
	if ll >= length:
		return r
	var ps = paddingString
	if ps == null:
		ps = "0"
	var sb = new StringBuilder()
	var n as int
	for(n=0; n<length-ll; n++):
		sb.append(ps)
	sb.append(r)
	return sb.toString()
}

**
** Converts an integer value to a string using the "base-16" or hexadecimal notation.
**

func forIntegerHex(vv as int #used, minlength as int = 0) static as string
{
	var v as string
	IFDEF "target_cs" {
		v = lang "cs" string {{{ vv.ToString("x") }}}
	}
	ELSE IFDEF "target_objc" {
		v = lang "objc" string {{{ [NSString stringWithFormat:@"%X", vv] }}}
	}
	ELSE IFDEF "target_java" {
		v = lang "java" string {{{ java.lang.Integer.toHexString(vv) }}}
	}
	ELSE IFDEF "target_js" {
		v = lang "js" string {{{ (~~vv).toString(16) }}}
	}
	ELSE IFDEF "target_kotlin" {
		v = lang "kotlin" string {{{ vv.toString(16) }}}
	}
	ELSE IFDEF "target_swift" {
		v = lang "swift" string {{{ Swift.String(format:"%x", vv) }}}
	}
	ELSE IFDEF "target_sushi" {
		v = lang "lua" string {{{ _sushi.createHexStringForInteger(vv) }}}
	}
	ELSE {
		ERROR "Not implemented"
		return null
	}
	assert v
	if minlength > 0 {
		while getLength(v) < minlength:
			v = "0" .. v
	}
	return v
}

**
** Converts an integer value to a string using the octal notation.
**

func forIntegerOctal(vv as int #used) static as string
{
	var v as string
	IFDEF "target_cs" {
		v = lang "cs" string {{{ System.Convert.ToString(vv, 8) }}}
	}
	ELSE IFDEF "target_objc" {
		v = lang "objc" string {{{ [NSString stringWithFormat:@"%o", vv] }}}
	}
	ELSE IFDEF "target_java" {
		v = lang "java" string {{{ java.lang.Integer.toOctalString(vv) }}}
	}
	ELSE IFDEF "target_js" {
		v = lang "js" string {{{ (~~vv).toString(8) }}}
	}
	ELSE IFDEF "target_kotlin" {
		v = lang "kotlin" string {{{ vv.toString(8) }}}
	}
	ELSE IFDEF "target_swift" {
		v = lang "swift" string {{{ Swift.String(format:"%o", vv) }}}
	}
	ELSE IFDEF "target_sushi" {
		v = lang "lua" string {{{ _sushi.createOctalStringForInteger(vv) }}}
	}
	ELSE {
		ERROR "Not implemented"
		return null
	}
	return v
}

**
** Converts a buffer of bytes to a string using the "base-16" or hexadecimal notation.
**

func forBufferHex(buffer as buffer) static as string
{
	var size = assert Buffer.getSize(buffer)
	var sb = new StringBuilder()
	var p = 0
	while p < size {
		var s = forIntegerHex(Buffer.getByte(buffer, p))
		if getLength(s) < 2:
			sb.append('0')
		sb.append(s)
		p ++
	}
	return sb.toString()
}

**
** Converts a character to a string. The result will be a single-character string.
**

func forCharacter(vv as char #used) static as string
{
	IFDEF "target_cs" {
		return lang "cs" string {{{ new string(vv, 1) }}}
	}
	ELSE IFDEF "target_objc" {
		var v as string
		lang "objc" {{{
			UInt32 h = (UInt32)vv;
			v = [[NSString alloc] initWithBytes:&h length:sizeof(h) encoding:NSUTF32LittleEndianStringEncoding];
		}}}
		return v
	}
	ELSE IFDEF "target_java" {
		return lang "java" string {{{ java.lang.String.valueOf(vv) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" string {{{ vv.toString() }}}
	}
	ELSE IFDEF "target_sushi" {
		if vv < 0x80 {
			return lang "lua" string {{{ _sushi.createStringForByte(vv) }}}
		}
		if vv < 0x800 {
			var v1 = 0xc0 | (vv >> 6)
			var v2 = 0x80 | (vv & 0x3f)
			return lang "lua" string {{{ _sushi.createStringForByte(v1) .. _sushi.createStringForByte(v2) }}}
		}
		if vv < 0x10000 {
			var v1 = 0xe0 | (vv >> 12)
			var v2 = 0x80 | ((vv >> 6) & 0x3f)
			var v3 = 0x80 | (vv & 0x3f)
			return lang "lua" string {{{ _sushi.createStringForByte(v1) .. _sushi.createStringForByte(v2) .. _sushi.createStringForByte(v3) }}}
		}
		var v1 = 0xf0 | (vv >> 18)
		var v2 = 0x80 | ((vv >> 12) & 0x3f)
		var v3 = 0x80 | ((vv >> 6) & 0x3f)
		var v4 = 0x80 | (vv & 0x3f)
		return lang "lua" string {{{ _sushi.createStringForByte(v1) .. _sushi.createStringForByte(v2) .. _sushi.createStringForByte(v3) .. _sushi.createStringForByte(v4) }}}
	}
	ELSE IFDEF "target_stdlua" {
		if vv < 0x80 {
			return lang "lua" string {{{ string.char(vv) }}}
		}
		if vv < 0x800 {
			var v1 = 0xc0 | (vv >> 6)
			var v2 = 0x80 | (vv & 0x3f)
			return lang "lua" string {{{ string.char(v1) .. string.char(v2) }}}
		}
		if vv < 0x10000 {
			var v1 = 0xe0 | (vv >> 12)
			var v2 = 0x80 | ((vv >> 6) & 0x3f)
			var v3 = 0x80 | (vv & 0x3f)
			return lang "lua" string {{{ string.char(v1) .. string.char(v2) .. string.char(v3) }}}
		}
		var v1 = 0xf0 | (vv >> 18)
		var v2 = 0x80 | ((vv >> 12) & 0x3f)
		var v3 = 0x80 | ((vv >> 6) & 0x3f)
		var v4 = 0x80 | (vv & 0x3f)
		return lang "lua" string {{{ string.char(v1) .. string.char(v2) .. string.char(v3) .. string.char(v4) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ vv.toString() }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" string {{{ vv.description }}}
	}
	ELSE {
		ERROR "Not implemented"
		return null
	}
}

**
** Converts a floating point value to a string.
**

func forFloat(vv as float #used) static as string
{
	IFDEF("target_objc") {
		return(lang "objc" string {{{ [NSString stringWithFormat:@"%f", vv] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ java.lang.String.valueOf(vv) }}})
	}
	ELSE IFDEF("target_cs") {
		return(lang "cs" string {{{ vv.ToString() }}})
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ vv.toString() }}})
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ vv.toString() }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" string {{{ _sushi.createStringForFloat(vv) }}}
	}
	ELSE IFDEF "target_stdlua" {
		return lang "lua" string {{{ tostring(vv) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" string {{{ vv.description }}}
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

**
** Converts a double-precision floating point value to a string.
**

func forDouble(vv as double #used) static as string
{
	IFDEF("target_objc") {
		return(lang "objc" string {{{ [NSString stringWithFormat:@"%f", vv] }}})
	}
	ELSE IFDEF("target_java") {
		return(lang "java" string {{{ java.lang.String.valueOf(vv) }}})
	}
	ELSE IFDEF("target_cs") {
		var v as string
		lang "cs" {{{
			v = vv.ToString();
			if(v != null && v.IndexOf('.') < 0) {
				v = v + ".0";
			}
		}}}
		return(v)
	}
	ELSE IFDEF("target_js") {
		return(lang "js" string {{{ vv.toString() }}})
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ vv.toString() }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" string {{{ _sushi.createStringForFloat(vv) }}}
	}
	ELSE IFDEF "target_stdlua" {
		return lang "lua" string {{{ tostring(vv) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" string {{{ vv.description }}}
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

**
** Converts a string to a buffer of bytes, encoded using the UTF8 encoding.
**

func toUTF8Buffer(str as string) static as buffer:
	return toBuffer(str, "UTF8")

**
** Converts a string to a buffer of bytes, encoded using the specified "charset"
** as the character set or encoding. Valid options for "charset" are platform
** dependent, and would include values such as UTF8, UTF16, UCS2 and ASCII.
** UTF8 encoding, however, is implemented for all platforms, and is therefore the
** recommended character set to use.
**

func toBuffer(str as string, charset as string) static as buffer
{
	assert str
	assert charset
	IFDEF "target_objc" {
		if equalsIgnoreCase("UTF8", charset) || equalsIgnoreCase("UTF-8", charset) {
			var v as buffer
			lang "objc" {{{
				v = [[str dataUsingEncoding:NSUTF8StringEncoding] mutableCopy];
			}}}
			return v
		}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" buffer {{{ str.toByteArray(kotlin.text.charset(charset))?.toUByteArray() }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" buffer {{{ NSMutableData(data: (Data(str.utf8))) }}}
	}
	ELSE IFDEF "target_stdlua" {
		if equalsIgnoreCase("UTF8", charset) || equalsIgnoreCase("UTF-8", charset) {
			var v as buffer
			lang "lua" {{{
				v = {}
				for i=1, #str do
					v[#v + 1] = string.byte(str, i)
				end
			}}}
			return v
		}
	}
	ELSE IFDEF "target_sushi" {
		if equalsIgnoreCase("UTF8", charset) || equalsIgnoreCase("UTF-8", charset):
			return lang "lua" buffer {{{ _sushi.convertStringToBuffer(str) }}}
	}
	var bytes = assert getBytesUnsigned(str, charset)
	var c = SIZE bytes
	var bb = MALLOC c
	var n as int
	for(n=0; n<c; n++):
		Buffer.setByte(bb, n, bytes[n])
	return bb
}

func getBytesUnsigned(str as string) private static as uint8[]:
	return getBytesUnsigned(str, "UTF-8")

func getBytesUnsigned(str as string #used, charset as string) private static as uint8[]
{
	assert str
	assert charset
	IFDEF("target_cs") {
		var bytes as uint8[]
		lang "cs" {{{
			System.Text.Encoding encoding;
			if("UTF-8".Equals(charset) || "UTF8".Equals(charset)) {
				encoding = System.Text.Encoding.UTF8;
			}
			else if("UTF-16".Equals(charset) || "UTF16".Equals(charset)) {
				encoding = System.Text.Encoding.Unicode;
			}
			else {
				return(null);
			}
			bytes = encoding.GetBytes(str);
		}}}
		return(bytes)
	}
	ELSE IFDEF("target_java") {
		var v as uint8[]
		lang "java" {{{
			try {
				v = str.getBytes(charset);
			}
			catch(java.lang.Exception e) {
				System.err.println(e.toString());
			}
		}}}
		return(v)
	}
	ELSE IFDEF("target_js") {
		var uintArray as array<uint8>
		if(equalsIgnoreCase(charset, "UTF-8") || equalsIgnoreCase(charset, "UTF8")) {
			lang "js" {{{
				uintArray = [];
				for(var i = 0; i < str.length; i++) {
					var cc = str.charCodeAt(i);
					if(cc < 0x80) {
						uintArray.push(cc);
					}
					else if(cc < 0x800) {
						uintArray.push(0xc0 | (cc >> 6));
						uintArray.push(0x80 | (cc & 0x3f));
					}
					else if(cc < 0xd800 || cc >= 0xe000) {
						uintArray.push(0xe0 | (cc >> 12));
						uintArray.push(0x80 | ((cc >> 6) & 0x3f));
						uintArray.push(0x80 | (cc & 0x3f));
					}
					else {
						i++;
						cc = (((cc & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff)) + 0x10000;
						uintArray.push(0xf0 | (cc >> 18));
						uintArray.push(0x80 | ((cc >> 12) & 0x3f));
						uintArray.push(0x80 | ((cc >> 6) & 0x3f));
						uintArray.push(0x80 | (cc & 0x3f));
					}
				}
			}}}
		}
		else if(equalsIgnoreCase(charset, "UTF-16") || equalsIgnoreCase(charset, "UTF16")) {
			lang "js" {{{
				uintArray = new Uint8Array(str.length);
				for(var c = 0; c < str.length; c++) {
					uintArray[c] = str.charCodeAt(c);
				}
			}}}
		}
		return(uintArray)
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" uint8[] {{{ str.toByteArray(kotlin.text.charset(charset))?.toUByteArray()?.toTypedArray() }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" uint8[] {{{ NSMutableArray(array: [UInt8](str.utf8)) }}}
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

func getBytesSigned(str as string) private static as int8[]
{
	return(getBytesSigned(str, "UTF-8"))
}

func getBytesSigned(str as string #used, charset as string) private static as int8[]
{
	if(str == null || charset == null) {
		return(null)
	}
	IFDEF("target_cs") {
		var bytes as int8[]
		lang "cs" {{{
			var enc = getBytesUnsigned(str, charset);
			if(enc == null) {
				return(null);
			};
			bytes = new sbyte[enc.Length];
			System.Buffer.BlockCopy(enc, 0, bytes, 0, bytes.Length);
		}}}
		return(bytes)
	}
	ELSE IFDEF("target_java") {
		var v as int8[]
		lang "java" {{{
			try {
				v = str.getBytes(charset);
			}
			catch(java.lang.Exception e) {
				System.err.println(e.toString());
			}
		}}}
		return(v)
	}
	ELSE IFDEF("target_js") {
		var intArray as array<int8>
		lang "js" {{{
			intArray = new Int8Array(str.length);
			for(var c = 0; c < str.length; c++) {
				intArray[c] = str.charCodeAt(c);
			}
		}}}
		return(intArray)
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" uint8[] {{{ str.toByteArray(kotlin.text.charset(charset)) }}}
	}
	ELSE {
		ERROR("Not implemented")
		return(null)
	}
}

**
** Gets the length of a string, representing the number of characters
** composing the string (note: This is not the same as the number of bytes
** allocated to hold the memory for the string).
**

func getLength(str as string #used) static as int
{
	if str == null:
		return 0
	IFDEF "target_cs" {
		return lang "cs" int {{{ str.Length }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" int {{{ [str length] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" int {{{ str.length() }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" int {{{ str.length }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" int {{{ str.length }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" int {{{ str.count }}}
	}
	ELSE {
		var it = iterate(str)
		var v = 0
		while it {
			var c = it.getNextChar()
			if Character.isEOF(c):
				break
			v++
		}
		return v
	}
}

**
** Appends a string "str2" to the end of another string "str1". Either one
** of the values may be null: If "str1" is null, the value of "str2" is returned,
** and if "str2" is null, the value of "str1" is returned.
**

func append(str1 as string #used, str2 as string #used) static as string
{
	if str1 == null:
		return str2
	if str2 == null:
		return str1
	IFDEF "target_cs" {
		return lang "cs" string {{{ System.String.Concat(str1, str2) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" string {{{ [str1 stringByAppendingString:str2] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" string {{{ str1.concat(str2 != null ? str2 : "") }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" string {{{ str1.concat(str2) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ str1.plus(str2) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" string {{{ str1! + str2! }}}
	}
	ELSE IFDEF "target_lua" {
		return lang "lua" string {{{ str1 .. str2 }}}
	}
	ELSE {
		ERROR "Not implemented"
		return str1
	}
}

**
** Appends an integer value "intvalue" to the end of string "str". If the
** original string is null, then a new string is returned, representing only
** the integer value.
**

func append(str as string, intvalue as int) static as string:
	return append(str, forInteger(intvalue))

**
** Appends a character value "charvalue" to the end of string "str". If the
** original string is null, then a new string is returned, representing only
** the character value.
**

func append(str as string, charvalue as char) static as string:
	return append(str, forCharacter(charvalue))

**
** Appends a floating point value "floatvalue" to the end of string "str". If the
** original string is null, then a new string is returned, representing only
** the floating point value.
**

func append(str as string, floatvalue as float) static as string:
	return append(str, forFloat(floatvalue))

**
** Appends a double-precision floating point value "doublevalue" to the end of
** string "str". If the original string is null, then a new string is returned,
** representing only the floating point value.
**

func append(str as string, doublevalue as double) static as string:
	return append(str, forDouble(doublevalue))

**
** Appends a boolean value "boolvalue" to the end of string "str". If the
** original string is null, then a new string is returned, representing only
** the boolean value.
**

func append(str as string, boolvalue as bool) static as string:
	return append(str, forBoolean(boolvalue))

**
** Converts all characters of a string to lowercase.
**

func toLowerCase(str as string #used) static as string
{
	assert str
	IFDEF "target_cs" {
		return lang "cs" string {{{ str.ToLower() }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" string {{{ [str lowercaseString] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" string {{{ str.toLowerCase() }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" string {{{ str.toLowerCase() }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ str.toLowerCase() }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" string {{{ _sushi.changeStringToLowercase(str) }}}
	}
	ELSE IFDEF "target_stdlua" {
		return lang "lua" string {{{ string.lower(str) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" string {{{ str.lowercased() }}}
	}
	ELSE {
		ERROR "Not implemented"
		return str
	}
}

**
** Converts all characters of a string to uppercase.
**

func toUpperCase(str as string #used) static as string
{
	assert str
	IFDEF "target_cs" {
		return lang "cs" string {{{ str.ToUpper() }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" string {{{ [str uppercaseString] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" string {{{ str.toUpperCase() }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" string {{{ str.toUpperCase() }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ str.toUpperCase() }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" string {{{ _sushi.changeStringToUppercase(str) }}}
	}
	ELSE IFDEF "target_stdlua" {
		return lang "lua" string {{{ string.upper(str) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" string {{{ str.uppercased() }}}
	}
	ELSE {
		ERROR "Not implemented"
		return str
	}
}

**
** Ensures that the first letter of the string is in uppercase.
**

func capitalize(str as string) static as string
{
	assert str
	var c = getChar(str, 0)
	if Character.isLowercaseAlpha(c) == false:
		return str
	return forCharacter(Character.toUppercase(c)) .. getSubString(str, 1)
}

**
** Gets a character with the specified index "index" from the given string.
** This method is deprecated: Use getChar() instead.
**

func charAt(str as string, index as int) static as char #deprecated:
	return getChar(str, index)

**
** Gets a character with the specified index "index" from the given string.
**

func getChar(str as string #used, index as int #used) static as char
{
	if str == null || index < 0:
		return 0 as char
	IFDEF "target_cs" {
		return lang "cs" char {{{ str == null || index < 0 || index >= str.Length ? (char)0 : str[index] }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" char {{{ str == nil || index < 0 || index >= [str length] ? 0 : [str characterAtIndex:index] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" char {{{ str == null || index < 0 || index >= str.length() ? (char)0 : str.charAt(index) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" char {{{ str == null || index < 0 || index >= str.length ? 0 : str[index] }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" char {{{ if (str == null || index < 0 || index >= str.length) 0.toChar() else str.get(index) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" char {{{ str == nil || index < 0 || index >= str.count ? Swift.Character(UnicodeScalar(0)) : str![str.index(str.startIndex, offsetBy: index)] }}}
	}
	ELSE {
		var it = iterate(str)
		var n = 0
		while it {
			var c = it.getNextChar()
			if Character.isEOF(c):
				break
			if n == index:
				return c
			n++
		}
		return 0 as char
	}
}

**
** Compares two strings, and returns true if both strings contain exactly
** the same contents (even though they may be represented by different objects).
** Either of the strings may be null, in which case the comparison always results
** to false.
**

func equals(str1 as string #used, str2 as string #used) static as bool
{
	if str1 == null && str2 == null:
		return true
	assert str1 && str2
	IFDEF "target_cs" {
		return lang "cs" bool {{{ str1.Equals(str2) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" bool {{{ [str1 isEqualToString:str2] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" bool {{{ str1.equals(str2) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" bool {{{ str1 === str2 }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" bool {{{ str1.equals(str2) }}}
	}
	ELSE IFDEF "target_lua" {
		return lang "lua" bool {{{ str1 == str2 }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" bool {{{ str1 == str2 }}}
	}
	ELSE {
		ERROR "Not implemented"
		return false
	}
}

**
** Compares two strings and returns true if both strings are not equal otherwise false.
**

func isNotEqual(str1 as string, str2 as string) static as bool:
	return not equals(str1, str2)

**
** Compares two strings for equality (like equals()) while considering uppercase
** and lowercase versions of the same character as equivalent. Eg. strings
** "ThisIsAString" and "thisisastring" would be considered equivalent, and the
** result of comparison would be "true".
**

func equalsIgnoreCase(str1 as string #used, str2 as string #used) static as bool
{
	if str1 == null && str2 == null:
		return true
	assert str1 && str2
	IFDEF "target_cs" {
		return lang "cs" bool {{{ System.String.Equals(str1, str2, System.StringComparison.OrdinalIgnoreCase) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" bool {{{ [str1 caseInsensitiveCompare:str2] == NSOrderedSame }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" bool {{{ str1.equalsIgnoreCase(str2) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" bool {{{ str1.toLowerCase() === str2.toLowerCase() }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" bool {{{ str1.equals(str2, true) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" bool {{{ str1.range(of: str2, options: .caseInsensitive) != nil }}}
	}
	ELSE {
		return equals(toLowerCase(str1), toLowerCase(str2))
	}
}

**
** Compares two strings, and returns an integer value representing their
** sorting order. The return value 0 indicates that the two strings are 
** equivalent. A negative return value (< 0) indicates that "str1" is
** less than "str2", and a positive return value (> 0) indicates that "str1"
** is greater than "str2". If either "str1" or "str2" is null, the comparison
** yields the value 0.
**

func compare(str1 as string #used, str2 as string #used) static as int
{
	if str1 == null || str2 == null:
		return 0
	IFDEF "target_cs" {
		return lang "cs" int {{{ System.String.Compare(str1, str2, false) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" int {{{ str1.compareTo(str2) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" int {{{ ({ NSComparisonResult _r = [str1 compare:str2]; _r == NSOrderedAscending ? -1 : (_r == NSOrderedSame ? 0 : 1); }) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" int {{{ str1.localeCompare(str2) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" int {{{ str1.compareTo(str2) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" int {{{ (str1! as NSString).compare(str2!).rawValue }}}
	}
	ELSE {
		var it1 = iterate(str1)
		var it2 = iterate(str2)
		if it1 == null || it2 == null:
			return 0
		loop {
			if it1.hasEnded() && it2.hasEnded():
				break
			if it1.hasEnded():
				return -1
			if it2.hasEnded():
				return 1
			var c1 = it1.getNextChar()
			var c2 = it2.getNextChar()
			if c1 < c2:
				return -1
			if c1 > c2:
				return 1
		}
		return 0
	}
}

**
** Compares strings exactly like compareTo(), but this method considers uppercase
** and lowercase versions of each character as equivalent.
**

func compareToIgnoreCase(str1 as string #used, str2 as string #used) static as int
{
	if str1 == null || str2 == null:
		return 0
	IFDEF "target_cs" {
		return lang "cs" int {{{ System.String.Compare(str1, str2, true) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" int {{{ str1.compareToIgnoreCase(str2) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" int {{{ ({ NSComparisonResult _r = [str1 caseInsensitiveCompare:str2]; _r == NSOrderedAscending ? -1 : (_r == NSOrderedSame ? 0 : 1); }) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" int {{{ str1.toLowerCase().localeCompare(str2.toLowerCase()) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" int {{{ str1.compareTo(str2, true) }}}
	}
	ELSE IFDEF "target_swift" {
		var n as int #used
		lang "swift" {{{
			let r = (str1! as NSString).caseInsensitiveCompare(str2!)
			n = r == ComparisonResult.orderedAscending ? -1 : r == ComparisonResult.orderedSame ? 0 : 1
		}}}
		return n
	}
	ELSE {
		var it1 = iterate(str1)
		var it2 = iterate(str2)
		if it1 == null || it2 == null:
			return 0
		loop {
			if it1.hasEnded() && it2.hasEnded():
				break
			if it1.hasEnded():
				return -1
			if it2.hasEnded():
				return 1
			var c1 = Character.toLowercase(it1.getNextChar())
			var c2 = Character.toLowercase(it2.getNextChar())
			if c1 < c2:
				return -1
			if c1 > c2:
				return 1
		}
		return 0
	}
}

**
** Gets a hash code version of the string as an integer.
**

func getHashCode(str as string #used) static as int
{
	if str == null:
		return 0
	IFDEF "target_cs" {
		return lang "cs" int {{{ str.GetHashCode() }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" int {{{ [str hash] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" int {{{ str.hashCode() }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" int {{{ str.hashCode() }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" int {{{ (str! as NSString).hash }}}
	}
	ELSE {
		var hash = 0
		var it = iterate(str)
		while it {
			var ch = it.getNextChar()
			if Character.isEOF(ch):
				break
			hash = ((hash << 5) - hash) + ch
			hash = hash & hash
		}
		return hash
	}
}

**
** Gets the first index of a given character "c" in string "str", starting from
** index "start". This method is deprecated, use getIndexOf() instead.
**

func indexOf(str as string, c as char, start as int = 0) static as int #deprecated:
	return getIndexOf(str, c, start)

**
** Gets the first index of a given character "c" in string "str", starting from
** index "start".
**

func getIndexOf(str as string #used, c as char #used, start as int #used = 0) static as int
{
	if str == null:
		return -1
	IFDEF "target_cs" {
		return lang "cs" int {{{ str.IndexOf(c, start) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" int {{{ str.indexOf((int)c, start) }}}
	}
	ELSE IFDEF "target_objc" {
		var v as int
		lang "objc" {{{
			NSRange r = [str rangeOfCharacterFromSet:[NSCharacterSet characterSetWithCharactersInString:[NSString stringWithFormat:@"%c", c]] options:0 range:NSMakeRange(start, [str length]-start)];
			if(r.location == NSNotFound) {
				v = -1;
			}
			else {
				v = r.location;
			}
		}}}
		return v
	}
	ELSE IFDEF "target_js" {
		return lang "js" int {{{ str.indexOf(c, start) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" int {{{ str.indexOf(c, start) }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" int {{{ _sushi.getIndexOfCharacter(str, c, start) }}}
	}
	ELSE IFDEF "target_swift" {
		var v as int #used
		lang "swift" {{{
			if let range = str.range(of: Swift.String(c)) {
				v = str.distance(from: str.startIndex, to: range.lowerBound)
			}
		}}}
		return v
	}
	ELSE {
		ERROR "Not implemented"
		return -1
	}
}

**
** Gets the first index of a given substring "s" in string "str", starting from
** index "start". This method is deprecated, use getIndexOf() instead.
**

func indexOf(str as string, s as string, start as int = 0) static as int #deprecated:
	return getIndexOf(str, s, start)

**
** Gets the first index of a given substring "s" in string "str", starting from
** index "start".
**

func getIndexOf(str as string #used, s as string #used, start as int #used = 0) static as int
{
	if str == null || s == null:
		return -1
	IFDEF "target_cs" {
		return lang "cs" int {{{ str.IndexOf(s, start) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" int {{{ str.indexOf(s, start) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" int {{{ [str rangeOfString:s options:0 range:NSMakeRange(start, [str length]-start)].location }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" int {{{ str.indexOf(s, start) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" int {{{ str.indexOf(s, start) }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" int {{{ _sushi.getIndexOfSubstring(str, s, start) }}}
	}
	ELSE IFDEF "target_swift" {
		var v as int #used
		lang "swift" {{{
			if let range = str.range(of: s)) {
				v = str.distance(from: str.startIndex, to: range.lowerBound)
			}
		}}}
		return v
	}
	ELSE {
		ERROR "Not implemented"
		return -1
	}
}

**
** Gets the last index of a given character "c" in string "str", starting from
** index "start". This method is deprecated, use getLastIndexOf() instead.
**

func lastIndexOf(str as string, c as char, start as int = -1) static as int #deprecated:
	return getLastIndexOf(str, c, start)

**
** Gets the last index of a given character "c" in string "str", starting from
** index "start".
**

func getLastIndexOf(str as string #used, c as char #used, start as int #used = -1) static as int
{
	if str == null:
		return -1
	IFDEF "target_cs" {
		if start < 0:
			return lang "cs" int {{{ str.LastIndexOf(c) }}}
		return lang "cs" int {{{ str.LastIndexOf(c, start) }}}
	}
	ELSE IFDEF "target_java" {
		if start < 0:
			return lang "java" int {{{ str.lastIndexOf((int)c) }}}
		return lang "java" int {{{ str.lastIndexOf((int)c, start) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" int {{{ [str rangeOfCharacterFromSet:[NSCharacterSet characterSetWithCharactersInString:[NSString stringWithFormat:@"%c", c]] options:NSBackwardsSearch range:NSMakeRange(0, start < 0 ? [str length] : start)].location }}}
	}
	ELSE IFDEF "target_js" {
		if start <= 0:
			return lang "js" int {{{ str.lastIndexOf(c) }}}
		return lang "js" int {{{ str.lastIndexOf(c, start) }}}
	}
	ELSE IFDEF "target_kotlin" {
		if start <= 0:
			return lang "kotlin" int {{{ str.lastIndexOf(c) }}}
		return lang "kotlin" int {{{ str.lastIndexOf(c, start) }}}
	}
	ELSE IFDEF "target_swift" {
		var n as int #used
		lang "swift" {{{
			let range: Range<String.Index> = str.range(of: Swift.String(c), options: .backwards)!
			n = str.distance(from: str.startIndex, to: range.lowerBound)
		}}}
		return n
	}
	ELSE {
		var ss = start
		if ss < 0:
			ss = 0
		var ii = getIndexOf(str, c, ss)
		if ii >= 0 {
			while true {
				var ix = getIndexOf(str, c, ii+1)
				if ix < 0:
					break
				ii = ix
			}
		}
		return ii
	}
}

**
** Gets the last index of a given substring "s" in string "str", starting from
** index "start". This method is deprecated, use getLastIndexOf() instead.
**

func lastIndexOf(str as string, s as string, start as int = -1) static as int #deprecated:
	return getLastIndexOf(str, s, start)

**
** Gets the last index of a given substring "s" in string "str", starting from
** index "start".
**

func getLastIndexOf(str as string #used, s as string #used, start as int #used = -1) static as int
{
	if str == null:
		return -1
	IFDEF "target_cs" {
		if start < 0:
			return lang "cs" int {{{ str.LastIndexOf(s) }}}
		return lang "cs" int {{{ str.LastIndexOf(s, start) }}}
	}
	ELSE IFDEF "target_java" {
		if start < 0:
			return lang "java" int {{{ str.lastIndexOf(s) }}}
		return lang "java" int {{{ str.lastIndexOf(s, start) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" int {{{ [str rangeOfString:s options:NSBackwardsSearch range:NSMakeRange(0, start < 0 ? [str length] : start)].location }}}
	}
	ELSE IFDEF "target_js" {
		if start <= 0:
			return lang "js" int {{{ str.lastIndexOf(s) }}}
		return lang "js" int {{{ str.lastIndexOf(s, start) }}}
	}
	ELSE IFDEF "target_kotlin" {
		assert s
		if start <= 0:
			return lang "kotlin" int {{{ str.lastIndexOf(s) }}}
		return lang "kotlin" int {{{ str.lastIndexOf(s, start) }}}
	}
	ELSE IFDEF "target_swift" {
		var n as int #used
		lang "swift" {{{
			let range: Range<String.Index> = str.range(of: s!, options: .backwards)!
			n = str.distance(from: str.startIndex, to: range.lowerBound)
		}}}
		return n
	}
	ELSE {
		var ss = start
		if ss < 0:
			ss = 0
		var ii = getIndexOf(str, s, ss)
		if ii >= 0 {
			while true {
				var ix = getIndexOf(str, s, ii+1)
				if ix < 0:
					break
				ii = ix
			}
		}
		return ii
	}
}

**
** Gets a substring of "str", starting from index "start". This method is
** deprecated, use getSubString() instead.
**

func subString(str as string, start as int) static as string #deprecated:
	return getSubString(str, start)

**
** Gets a substring of "str", starting from index "start".
**

func getSubString(str as string #used, start as int #used) static as string
{
	assert str
	if start >= getLength(str):
		return ""
	var ss = start
	if ss < 0:
		ss = 0
	IFDEF "target_cs" {
		return lang "cs" string {{{ str.Substring(ss) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" string {{{ str.substring(ss) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" string {{{ [str substringFromIndex:ss] }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" string {{{ str.substring(ss) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ str.substring(ss) }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" string {{{ _sushi.getSubstring(str, ss, #str) }}}
	}
	ELSE IFDEF "target_swift" {
		var v as string #used
		lang "swift" {{{
			let startIdx = str.index(str.startIndex, offsetBy: ss)
			v = Swift.String(str![startIdx...])
		}}}
		return v
	}
	ELSE {
		ERROR "Not implemented"
		return str
	}
}

**
** Gets a substring of "str", starting from index "start" and with a maximum
** length of "length". This method is deprecated, use getSubString() instead.
**

func subString(str as string, start as int, length as int) static as string #deprecated:
	return getSubString(str, start, length)

**
** Gets a substring of "str", starting from index "start" and with a maximum
** length of "length".
**

func getSubString(str as string #used, start as int #used, length as int #used) static as string
{
	assert str
	var ss = start
	if ss < 0:
		ss = 0
	var ll = length
	IFDEF "target_cs" {
		return lang "cs" string {{{ str.Substring(ss, ll)  }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" string {{{ [str substringWithRange:NSMakeRange(ss, ll)] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" string {{{ str.substring(ss, ss+ll) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" string {{{ str.substring(ss, ss+ll) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ str.substring(ss, ss+ll) }}}
	}
	ELSE IFDEF "target_sushi" {
		var v = lang "lua" string {{{ _sushi.getSubstring(str, ss, ss+ll) }}}
		if not v:
			v = ""
		return v
	}
	ELSE IFDEF "target_swift" {
		var v as string #used
		lang "swift" {{{
			let fromIndex = str.index(str.startIndex, offsetBy: ss)
			let toIndex = str.index(str.endIndex, offsetBy: (ss - str.count) + ll)
			v = str.substring(with: fromIndex..<toIndex)
		}}}
		return v
	}
	ELSE {
		ERROR "Not implemented"
		return str
	}
}

**
** Checks is the string "str1" contains a substring "str2". Returns true
** if the substring is found.
**

func contains(str1 as string, str2 as string) static as bool
{
	assert str1
	assert str2
	IFDEF "target_cs" {
		return lang "cs" bool {{{ str1.Contains(str2)  }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" bool {{{ [str1 containsString:str2] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" bool {{{ str1.contains(str2)  }}}
	}
	ELSE IFDEF "target_js" {
		var x as bool #used
		lang "js" {{{
			if(!str1.includes) {
				x = str1.indexOf(str2) !== -1;
			}
			else {
				x = str1.includes(str2);
			}
		}}}
		return x
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" bool {{{ str1.contains(str2) }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" bool {{{ (str1! as NSString).contains(str2!) }}}
	}
	ELSE {
		if getIndexOf(str1, str2) >= 0:
			return true
		return false
	}
}

**
** Checks if the string "str1" starts with the complete contents of "str2".
** If the "offset" parameter is supplied an is greater than zero, the checking
** does not start from the beginning of "str1" but from the given character index.
**

func startsWith(str1 as string, str2 as string #used, offset as int = 0) static as bool
{
	assert str1
	assert str2
	var nstr as string #used
	if offset > 0 {
		nstr = getSubString(str1, offset)
	}
	else {
		nstr = str1
	}
	IFDEF "target_cs" {
		return lang "cs" bool {{{ nstr.StartsWith(str2) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" bool {{{ [nstr hasPrefix:str2] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" bool {{{ nstr.startsWith(str2) }}}
	}
	ELSE IFDEF "target_js" {
		var x as bool #used
		lang "js" {{{
			if(!nstr.startsWith) {
				x = nstr.indexOf(str2) === 0;
			}
			else {
				x = nstr.startsWith(str2);
			}
		}}}
		return x
	}
	ELSE IFDEF "target_kotlin" {
		assert nstr
		return lang "kotlin" bool {{{ nstr.startsWith(str2) }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" bool {{{ _sushi.getSubstring(str1, 0, _sushi.getStringLength(str2)) == str2 }}}
	}
	ELSE IFDEF "target_stdlua" {
		return lang "lua" bool {{{ string.sub(str1, 1, string.len(str2)) == str2 }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" bool {{{ nstr.hasPrefix(str2!) }}}
	}
	ELSE {
		ERROR "Not Implemented"
		return false
	}
}

**
** Checks if the string "str" starts with any of the strings "strings". The
** matching string will be returned by the method, or null if none of the
** strings matched.
**

func startsWith(str as string, strings as array) static as string
{
	foreach str2 as string in strings {
		if startsWith(str, str2):
			return str2
	}
	return null
}

**
** Checks if the string "str1" starts with the complete contents of "str2", ignoring
** any differences between uppercase and lowercase characters. If the "offset" parameter
** is supplied an is greater than zero, the checking does not start from the beginning of
** "str1" but from the given character index.
**

func startsWithIgnoreCase(str1 as string, str2 as string, offset as int = 0) static as bool:
	return startsWith(toLowerCase(str1), toLowerCase(str2), offset)

**
** Checks if the string "str" starts with any of the strings "strings", ignoring any
** differences between uppercase and lowercase characters. The matching string will
** be returned by the method, or null if none of the strings matched.
**

func startsWithIgnoreCase(str as string, strings as array) static as string
{
	var ostr = toLowerCase(str)
	foreach str2 as string in strings {
		if startsWith(ostr, toLowerCase(str2)):
			return str2
	}
	return null
}

**
** Checks if the string "str1" ends with the complete contents of "str2".
**

func endsWith(str1 as string #used, str2 as string #used) static as bool
{
	assert str1
	assert str2
	IFDEF "target_cs" {
		return lang "cs" bool {{{ str1.EndsWith(str2) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" bool {{{ [str1 hasSuffix:str2] }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" bool {{{ str1.endsWith(str2) }}}
	}
	ELSE IFDEF "target_js" {
		var x as bool #used
		lang "js" {{{
			if(!str1.endsWith) {
				x = str1.indexOf(str2) === str1.length - str2.length;
			}
			else {
				x = str1.endsWith(str2);
			}
		}}}
		return x
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" bool {{{ str1.endsWith(str2) }}}
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" bool {{{ _sushi.getSubstring(str1, _sushi.getStringLength(str1)-_sushi.getStringLength(str2), _sushi.getStringLength(str1)) == str2 }}}
	}
	ELSE IFDEF "target_stdlua" {
		return lang "lua" bool {{{ string.sub(str1, string.len(str1)-string.len(str2), string.len(str1)) == str2 }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" bool {{{ str1.hasSuffix(str2!) }}}
	}
	ELSE {
		ERROR "Not Implemented"
		return false
	}
}

**
** Checks if the string "str" ends with any of the strings "strings". The
** matching string will be returned by the method, or null if none of the
** strings matched.
**

func endsWith(str as string, strings as array) static as string
{
	foreach str2 as string in strings {
		if endsWith(str, str2):
			return str2
	}
	return null
}

**
** Checks if the string "str1" ends with the complete contents of "str2", ignoring
** any differences between uppercase and lowercase characters.
**

func endsWithIgnoreCase(str1 as string, str2 as string) static as bool:
	return endsWith(toLowerCase(str1), toLowerCase(str2))

**
** Checks if the string "str" ends with any of the strings "strings", ignoring any
** differences between uppercase and lowercase characters. The matching string will
** be returned by the method, or null if none of the strings matched.
**

func endsWithIgnoreCase(str as string, strings as array) static as string
{
	var ostr = toLowerCase(str)
	foreach str2 as string in strings {
		if endsWith(ostr, toLowerCase(str2)):
			return str2
	}
	return null
}

**
** Strips (or trims) the given string "str" by removing all blank characters
** from both ends (the beginning and the end) of the string.
**

func strip(str as string #used) static as string
{
	assert str
	IFDEF "target_cs" {
		return lang "cs" string {{{ str.Trim() }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" string {{{ str.trim() }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" string {{{ str.trim() }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" string {{{ [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ str.trim() }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" string {{{ (str! as NSString).trimmingCharacters(in: CharacterSet.whitespacesAndNewlines) }}}
	}
	ELSE {
		return stripFromStart(stripFromEnd(str))
	}
}

**
** Strips (or trims) the given string "str" by removing all blank characters
** from the end of the string.
**

func stripFromEnd(str as string #used) static as string
{
	assert str
	IFDEF "target_cs" {
		return lang "cs" string {{{ str.TrimEnd(null) }}}
	}
	ELSE {
		var ll = getLength(str)
		if ll < 1:
			return str
		var n = 0
		loop {
			var c = getChar(str, ll - 1 - n)
			if c == ' ' || c == '\t' || c == '\r' || c == '\n' {
				n ++
			}
			else {
				break
			}
		}
		if n < 1:
			return str
		return getSubString(str, 0, ll - n)
	}
}

**
** Strips (or trims) the given string "str" by removing all blank characters
** from the beginning of the string.
**

func stripFromStart(str as string #used) static as string
{
	assert str
	IFDEF "target_cs" {
		return lang "cs" string {{{ str.TrimStart(null) }}}
	}
	ELSE {
		var n = 0
		loop {
			var c = getChar(str, n)
			if c == ' ' || c == '\t' || c == '\r' || c == '\n' {
				n ++
			}
			else {
				break
			}
		}
		if n < 1:
			return str
		return getSubString(str, n)
	}
}

**
** Replaces all instances of "oldChar" with the value of "newChar" in the given
** string "str". The return value is a new string where the changes have been
** effected. The original string remains unchanged.
**

func replace(str as string #used, oldChar as char #used, newChar as char #used) static as string
{
	assert str
	IFDEF "target_cs" {
		return lang "cs" string {{{ str.Replace(oldChar, newChar) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" string {{{ str.replace(oldChar, newChar) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" string {{{ str.replace(oldChar, newChar) }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ str.replace(oldChar, newChar) }}}
	}
	ELSE IFDEF "target_swift" {
		var v as string #used
		lang "swift" {{{
			let oldCharRange: Range<String.Index> = str!.range(of: Swift.String(oldChar))!
			let oldCharIdx: Int = str!.distance(from: str!.startIndex, to: oldCharRange.lowerBound)
			let oldCharStart = str!.index(str!.startIndex, offsetBy: oldCharIdx)
			let oldCharEnd = str!.index(str!.startIndex, offsetBy:  oldCharIdx + Swift.String(oldChar).count)
			v = str
			v!.replaceSubrange(oldCharStart..<oldCharEnd, with: Swift.String(newChar))
		}}}
		return v
	}
	ELSE {
		return replace(str, forCharacter(oldChar), forCharacter(newChar))
	}
}

**
** Replaces all instances of the substring "target" with the value of "replacement"
** in the given string "str". The return value is a new string where the changes
** have been effected. The original string remains unchanged.
**

func replace(str as string #used, target as string #used, replacement as string #used) static as string
{
	assert str
	if isEmpty(target):
		return str
	var rr = replacement
	if not rr:
		rr = ""
	IFDEF "target_cs" {
		return lang "cs" string {{{ str.Replace(target, rr) }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" string {{{ str.replace(target, rr) }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" string {{{ str.replace(target, rr) }}}
	}
	ELSE IFDEF "target_objc" {
		return lang "objc" string {{{ [str stringByReplacingOccurrencesOfString: target withString: rr] }}}
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" string {{{ str!!.replace(target!!, rr, false) }}}
	}
	ELSE IFDEF "target_swift" {
		var v as string #used
		lang "swift" {{{
			let oldStrRange: Range<String.Index> = str!.range(of: target!)!
			let oldStrIdx: Int = str!.distance(from: str!.startIndex, to: oldStrRange.lowerBound)
			let start = str!.index(str!.startIndex, offsetBy: oldStrIdx)
			let end = str!.index(str!.startIndex, offsetBy:  oldStrIdx + target!.count)
			v = str
			v!.replaceSubrange(start..<end, with: rr!)
		}}}
		return v
	}
	ELSE {
		var v = str
		loop {
			var p = getIndexOf(v, target)
			if p < 0:
				break
			var sb = new StringBuilder()
			sb.append(getSubString(v, 0, p))
			sb.append(rr)
			sb.append(getSubString(v, p + getLength(target)))
			v = sb.toString()
		}
		return v
	}
}

**
** Converts the string "str" to an array of characters.
**

func toCharArray(str as string #used) static as char[]
{
	assert str
	IFDEF "target_cs" {
		return lang "cs" char[] {{{ str.ToCharArray() }}}
	}
	ELSE IFDEF "target_java" {
		return lang "java" char[] {{{ str.toCharArray() }}}
	}
	ELSE IFDEF "target_js" {
		return lang "js" char[] {{{ str }}}
	}
	ELSE IFDEF "target_objc" {
		var ca as char[]
		lang "objc" {{{
			ca = [[NSMutableArray alloc] init];
			for(int i = 0; i < [str length]; i++) {
				CFStringRef strcf = (__bridge CFStringRef)str;
				CFRange r = CFStringGetRangeOfComposedCharactersAtIndex(strcf, i);
				if(r.length > 1) {
					UniChar v[r.length];
					CFStringGetCharacters(strcf, r, v);
					for(int x = 0; x < r.length; x++) {
						if((x + 1) < r.length && CFStringIsSurrogateHighCharacter(v[x]) && CFStringIsSurrogateLowCharacter(v[x + 1])) {
							UTF32Char c = CFStringGetLongCharacterForSurrogatePair(v[x], v[x + 1]);
							[ca addObject:[NSNumber numberWithUnsignedInt:c]];
							x++;
							continue;
						}
						[ca addObject:[NSNumber numberWithUnsignedInt:v[x]]];
					}
					i += (r.length - 1);
					continue;
				}
				UniChar v[1];
				CFStringGetCharacters(strcf, r, v);
				[ca addObject:[NSNumber numberWithUnsignedInt:v[0]]];
			}
		}}}
		return ca
	}
	ELSE IFDEF "target_kotlin" {
		return lang "kotlin" char[] {{{ str.toCharArray() }}}
	}
	ELSE IFDEF "target_swift" {
		return lang "swift" char[] {{{ NSMutableArray(array: Array(str!)) }}}
	}
	ELSE IFDEF "target_lua" {
		var it = iterate(str)
		var v as array<char>
		lang "lua" {{{
			v = {}
		}}}
		while it {
			var c = it.getNextChar()
			if Character.isEOF(c):
				break
			lang "lua" {{{
				v[#v + 1] = c
			}}}
		}
		return v
	}
	ELSE {
		ERROR "Not Implemented"
		return null
	}
}

**
** Splits the string "str" to a vector of strings, cutting the original string
** at each instance of the character "delim". If the value of "max" is supplied
** and is given a value greater than 0, then the resulting vector will only have
** a maximum of "max" entries. If the delimiter character appears beyond the
** maximum entries, the last entry in the vector will be the complete remainder
** of the original string, including the remaining delimiter characters.
**

func split(str as string, delim as char, max as int = 0) static as vector<string>
{
	var v = new vector<string>
	if str == null:
		return v
	var n = 0
	loop {
		if max > 0 && Vector.getSize(v) >= max - 1 {
			Vector.append(v, getSubString(str, n))
			break
		}
		var x = indexOf(str, delim, n)
		if x < 0 {
			Vector.append(v, getSubString(str, n))
			break
		}
		Vector.append(v, getSubString(str, n, x - n))
		n = x + 1
	}
	return v
}

**
** Checks if the given string is fully an integer (no other characters
** appear in the string).
**

func isInteger(str as string) static as bool
{
	assert str
	var it = assert iterate(str)
	loop {
		var c = it.getNextChar()
		if c < 1:
			break
		if c < '0' || c > '9':
			return false
	}
	return true
}

**
** Converts the string to an integer. If the string does not represent a valid
** integer, than the value "0" is returned.
**
** Eg. toInteger("99") = 99
** Eg. toInteger("asdf") = 0
**

func toInteger(str as string) static as int
{
	if isEmpty(str):
		return 0
	var v = 0
	var m = getLength(str)
	var n as int
	var negative = false
	for(n = 0; n < m; n++) {
		var c = charAt(str, n)
		if n == 0 && c == '-' {
			negative = true
			continue
		}
		if c >= '0' && c <= '9' {
			v = v * 10
			v += (c - '0') as int
		}
		else {
			break
		}
	}
	if negative:
		v *= -1
	return v
}

**
** Converts the string to a long integer. If the string does not represent a valid
** integer, than the value "0" is returned.
**
** Eg. toLong("99") = 99
** Eg. toLong("asdf") = 0
**

func toLong(str as string) static as long
{
	if isEmpty(str):
		return 0
	var v = 0 as long
	var m = getLength(str)
	var n as int
	var negative = false
	for(n = 0; n < m; n++) {
		var c = charAt(str, n)
		if n == 0 && c == '-' {
			negative = true
			continue
		}
		if c >= '0' && c <= '9' {
			v = v * 10
			v += (c - '0') as long
		}
		else {
			break
		}
	}
	if negative:
		v *= -1
	return v
}

**
** Converts the string to an integer, while treating the string as a hexadecimal
** representation of a number, eg. toIntegerFromHex("a") = 10
**

func toIntegerFromHex(str as string) static as int
{
	if isEmpty(str):
		return 0
	var v = 0
	var m = getLength(str)
	var n as int
	for(n = 0; n < m; n++) {
		var c = charAt(str, n)
		if c >= '0' && c <= '9' {
			v = v * 16
			v += (c - '0') as int
		}
		else if c >= 'a' && c <= 'f' {
			v = v * 16
			v += (10 + c - 'a') as int
		}
		else if c >= 'A' && c <= 'F' {
			v = v * 16
			v += (10 + c - 'A') as int
		}
		else {
			break
		}
	}
	return v
}

**
** Converts the string to an integer, while treating the string as an octal
** representation of a number.
**

func toIntegerFromOctal(str as string) static as int
{
	if isEmpty(str):
		return 0
	var v = 0
	var m = getLength(str)
	var n as int
	for(n = 0; n < m; n++) {
		var c = charAt(str, n)
		if c >= '0' && c <= '7' {
			v = v * 8
			v += (c - '0') as int
		}
		else {
			break
		}
	}
	return v
}

**
** Converts the string to a double-precision floating point number. If the
** string does not contain a valid representation of a floating point number,
** then the value "0.0" is returned.
**

func toDouble(str as string #used) static as double
{
	if str == null:
		return 0.0
	IFDEF "target_objc" {
		return lang "objc" double {{{ [str doubleValue] }}}
	}
	ELSE IFDEF "target_cs" {
		var v = 0.0
		lang "cs" {{{
			try {
				v = System.Double.Parse(str);
			}
			catch {
				v = 0.0;
			}
		}}}
		return v
	}
	ELSE IFDEF "target_java" {
		var v = 0.0
		lang "Java" {{{
			try {
				if(str != null) {
					v = java.lang.Double.parseDouble(str);
				}
			}
			catch(java.lang.Exception e) {
				v = 0.0;
			}
		}}}
		return v
	}
	ELSE IFDEF "target_js" {
		var v as double #used
		lang "js" {{{
			v = parseFloat(str);
			if (isNaN(v)) {
				v =  0.0;
			}
		}}}
		return v
	}
	ELSE IFDEF "target_kotlin" {
		var v = 0.0
		lang "kotlin" {{{
			try {
				v = str.toDouble()
			}
			catch (e: NumberFormatException) {
				v = 0.0
			}
		}}}
		return v
	}
	ELSE IFDEF "target_swift" {
		var v as double #used
		lang "swift" {{{
			var d = Swift.Double(str)
			v = d != nil ? d! : 0.0
		}}}
		return v
	}
	ELSE IFDEF "target_sushi" {
		return lang "lua" double {{{ _sushi.toNumber(str) }}}
	}
	ELSE {
		ERROR "Not Implemented"
		return 0.0
	}
}

**
** Iterates the string "string" character by character by using an
** instance of CharacterIterator.
**

func iterate(string as string) static as CharacterIterator:
	return CharacterIteratorForString.forString(string)

**
** Creates a new string that contains the same contents as "string", but with
** all characters appearing in reverse order.
**

func reverse(string as string) static as string
{
	assert string
	var sb = new StringBuilder()
	var it = iterate(string)
	var c as char
	while((c = it.getNextChar()) > 0):
		sb.insert(0, c)
	return sb.toString()
}

**
** Iterates the string "string" in reverse order (starting from the end, moving
** towards the beginning).
**

func iterateReverse(string as string) static as CharacterIterator:
	return iterate(reverse(string))

**
** Creates a new string based on "string" that is at least "length" characters
** long. If the original string is shorter, it will be padded to the desired length
** by adding instances of paddingCharacter (default of which is the space character).
** The "aling" attribute may be either -1, 0 or 1, and determines if the padding
** characters willb e added to the end, both sides or to the beginning, respectively.
**

func padToLength(string as string, length as int, align as int = -1, paddingCharacter as char = ' ') static as string
{
	var ll as int
	if string == null {
		ll = 0
	}
	else {
		ll = getLength(string)
	}
	if ll >= length:
		return string
	var add = length - ll
	var n = 0
	var sb = new StringBuilder()
	if align < 0 {
		sb.append(string)
		for(n=0; n<add; n++):
			sb.append(paddingCharacter)
	}
	else if align == 0 {
		var ff = add / 2
		var ss = add - ff
		for(n=0; n<ff; n++):
			sb.append(paddingCharacter)
		sb.append(string)
		for(n=0; n<ss; n++):
			sb.append(paddingCharacter)
	}
	else {
		for(n=0; n<add; n++):
			sb.append(paddingCharacter)
		sb.append(string)
	}
	return sb.toString()
}

**
** Splits the given string "str" to a vector of multiple strings, cutting the
** string at each instance of the "delim" character where the delim does not
** appear enclosed in either double quotes or single quotes.
**
** Eg. quotedStringToVector("first 'second third'", ' ') => [ "first", "second third" ]
**

func quotedStringToVector(str as string, delim as char, ignoreRepeatedDelimiters as bool = true, escapeCharacter as char = '\\') static as vector<string>
{
	var v = new vector<string>
	if str == null:
		return v
	var dquote = false
	var quote = false
	var sb as StringBuilder = null
	var it = iterate(str)
	loop {
		var c = it.getNextChar()
		if Character.isEOF(c):
			break
		if c == '"' && quote == false {
			dquote = !dquote
		}
		else if c == '\'' && dquote == false {
			quote = !quote
		}
		else if quote == false && dquote == false && c == delim {
			if sb {
				var r = sb.toString()
				if r == null:
					r = ""
				v += r
			}
			else if ignoreRepeatedDelimiters == false {
				v += ""
			}
			sb = null
		}
		else {
			if escapeCharacter > 0 && c == escapeCharacter {
				c = it.getNextChar()
				if Character.isEOF(c):
					break
			}
			if sb == null:
				sb = new StringBuilder()
			sb.append(c)
		}
		if((quote == true || dquote == true) && sb == null):
			sb = new StringBuilder()
	}
	if sb {
		var r = sb.toString()
		if r == null:
			r = ""
		v += r
	}
	return v
}

**
** Parses the string "str", splitting it to multiple strings using quotedStringToVector(),
** and then further processing it to key/value pairs, splitting each string at the
** equal sign '=' and adding the entries to a map.
**

func quotedStringToMap(str as string, delim as char) static as map<string,string>
{
	var v = new map<string,string>
	var vector = quotedStringToVector(str, delim)
	foreach c in vector {
		var sp = split(c, '=', 2)
		var key = sp[0]
		var val = sp[1]
		if isEmpty(key) == false:
			v[key] = val
	}
	return v
}

**
** Combines a vector of strings to a single string, incorporating the "delim"
** character between each string in the vector. If the "unique" variable is set to
** "true", only one instance of each unique string will be appended to the resulting
** string.
**

func combine(strings as vector<string>, delim as char, unique as bool = false) static as string
{
	var sb = new StringBuilder()
	var flags as map<string,string>
	if unique:
		flags = new map<string,string>
	foreach o as string in strings {
		if o == null:
			continue
		if flags {
			if Map.get(flags, o):
				continue
			Map.set(flags, o, "true")
		}
		if delim > 0 && sb.count() > 0:
			sb.append(delim)
		sb.append(o)
	}
	return sb.toString()
}

**
** Vaidates a string character-by-character, calling the supplied function to determine
** the validity of each character. Returns true if the entire string was validated, false if not.
**

func validateCharacters(str as string, validator as function<bool,char>) static as bool
{
	assert str
	var it = assert iterate(str)
	loop {
		var c = it.getNextChar()
		if c < 1:
			break
		if validator(c) == false:
			return false
	}
	return true
}

**
** Converts a vector of objects to a vector of strings. If the allowConversion parameter is
** true, attempts to also convert any non-string objects in the original vector to string objects,
** if possible. In either case, any objects that are either not strings or not convertible to strings,
** will be omitted from the resulting vector.
**

func toStringVector(vector as vector, allowConversion as bool = true) static as vector<string>
{
	var v = new vector<string>
	foreach o in vector {
		if allowConversion {
			var s = asString(o)
			if s:
				v += s
		}
		else {
			if o is string:
				v += o as! string
		}
	}
	return v
}

**
** Converts a vector of strings to a vector of objects. No operations are performed on the elements.
**

func toObjectVector(vector as vector<string>) static as vector
{
	IFDEF "target_lua" {
		return vector as! vector
	}
	ELSE {
		var v = new vector
		foreach o in vector:
			v += o
		return v
	}
}
