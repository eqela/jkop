
/*
 * This file is part of Jkop
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class abstract:

import cape
import capex.data
import capex.net
import capex.crypto

prop server as WSServer
prop port = 9090
var ctx protected as LoggingContext
var connectionSize private as int
var random private as Random

func authenticateConnection(data as buffer, callback as function<void, string>) abstract
func getUser(userId as string, callback as function<void, ChatUser>) abstract
func getUserCount(callback as function<void, int>) abstract
func createChannel(message as ChatMessage, callback as function<void, ChatChannel>) abstract
func getChannel(channelId as string, callback as function<void, ChatChannel>) abstract
func createAcknowledgeCommand(userId as string, callback as function<void, ChatMessage>) abstract
func createMessage(data as buffer, callback as function<void, ChatMessage>) abstract
func checkRecipients(recipients as DynamicVector, callback as function<void, bool>) abstract
func onUserOnline(user as ChatUser) abstract
func onUserOffline(user as ChatUser) abstract
func onNewCommandMessage(message as ChatMessage, connection as ChatConnectionHandler) abstract
func notifyUserForNewDataMessage(user as ChatUser, message as ChatMessage) abstract

ctor
{
	connectionSize = 0
	random = new Random()
}

func initialize virtual as bool:
	return true

func setCtx(ctx as LoggingContext):
	this.ctx = ctx

func getCtx as LoggingContext:
	return ctx

func initializeEngine(mgr as IOManager) as bool
{
	assert mgr:
		logError("No IOManager instance specified.")
	if not server {
		logWarning("No WebSocket server instance specified. Creating a new instance to listen on port: " .. String.forInteger(port) .. ".")
		server = new WSServer()
	}
	server.setPort(port)
	var engine final = this
	server.setCreateConnectionHandlerObject(func as WSServerConnectionHandler {
		return new ChatConnectionHandler().setEngine(engine).setLogContext(ctx)
	})
	assert server.initialize(mgr, ctx):
		logError("Failed to initialize WebSocket server.")
	assert initialize():
		logError("Failed to initialize chat engine.")
	logInfo("Successfully initialized chat engine.")
	return true
}

func generateId virtual as string:
	return MD5Encoder.encode(String.forInteger(SystemClock.asUTCSeconds()) .. String.forInteger(random.nextInt(9999999)) .. String.forInteger(random.nextInt(9999999)) .. String.forInteger(random.nextInt(9999999)))

func logError(message as string):
	Log.error(ctx, VALUE "__THIS__" .. ": " .. message)

func logWarning(message as string):
	Log.warning(ctx, VALUE "__THIS__" .. ": " .. message)

func logInfo(message as string):
	Log.info(ctx, VALUE "__THIS__" .. ": " .. message)

func logDebug(message as string):
	Log.debug(ctx, VALUE "__THIS__" .. ": " .. message)

func onDataReceived(data as buffer, connection as ChatConnectionHandler)
{
	assert connection
	assert data {
		connection.close()
	}
	var user = connection.getUser()
	if not user {
		onAuthenticateConnection(data, connection)
		return
	}
	onParseData(data, connection)
}

func onAuthenticateConnection(data as buffer, connection as ChatConnectionHandler) private
{
	authenticateConnection(data, func(userId as string) {
		assert String.isNotEmpty(userId) {
			logError("No userId returned by authenticateConnection() abstract method. Closing the connection instead.")
			connection.close()
		}
		getUser(userId, func(user as ChatUser) {
			assert user {
				logError("No ChatUser instance returned by getUser() abstract method. Closing the connection instead.")
				connection.close()
			}
			connection.setUser(user)
			loop {
				var connectionId = generateId()
				assert String.isNotEmpty(connectionId) {
					logError("No connectionId returned by generateId() abstract method. Closing the connection instead.")
					connection.close()
				}
				if not user.getConnection(connectionId) {
					connection.setConnectionId(connectionId)
					break
				}
			}
			user.addConnection(connection)
			connectionSize++
			getUserCount(func(count as int) {
				logDebug("New connection. Now: (" .. String.forInteger(connectionSize) .. "/" .. String.forInteger(count) .. ") connected")
			})
			createAcknowledgeCommand(userId, func(message as ChatMessage) {
				assert message {
					logError("Failed to create an acknowledge command message that the client is connected. Closing the connection instead.")
					connection.close()
				}
				assert message.getMessageType() == ChatMessage.COMMAND_TYPE {
					logError("Acknowledge command message not of type command. Closing the connection instead.")
					connection.close()
				}
				var r = connection.sendMessage(message)
				assert r > 0 {
					logError("Failed to send message. Closing the connection instead.")
					connection.close()
				}
				if user.getConnectionCount() == 1 {
					logDebug("User: '" .. user.getUserId() .. "' is now online")
					onUserOnline(user)
				}
			})
		})
	})
}

func onUserDisconnect(userId as string, connection as ChatConnectionHandler)
{
	getUser(userId, func(user as ChatUser) {
		assert user
		user.removeConnection(connection)
		connectionSize--
		getUserCount(func(count as int) {
			logDebug("Connection closed. Now: (" .. String.forInteger(connectionSize) .. "/" .. String.forInteger(count) .. ") connected")
		})
		if not user.isOnline() {
			logDebug("User: '" .. user.getUserId() .. "' is now offline with last active on: " .. String.forLongInteger(user.getLastActive()))
			onUserOffline(user)
		}
	})
}

func onParseData(data as buffer, connection as ChatConnectionHandler) private
{
	assert connection
	assert data {
		logError("No data buffer received. Closing the connection instead.")
		connection.close()
	}
	createMessage(data, func(message as ChatMessage) {
		assert message {
			logError("No ChatMessage instance returned by createMessage() abstract method. Closing the connection instead.")
			connection.close()
		}
		switch message.getMessageType() {
			case ChatMessage.COMMAND_TYPE: {
				// We would want to have commands
				// like: SEEN, TYPING, ONLINE, OFFLINE,
				// UPLOADING_FILE, DONE_UPLOADING_FILE, etc.
				onNewCommandMessage(message, connection)
				break
			}
			case ChatMessage.DATA_TYPE: {
				onNewDataMessage(message, connection)
				break
			}
			case ChatMessage.UNKNOWN_TYPE: {
				;
			}
			default: {
				logError("ChatMessage message type is invalid. Closing the connection instead.")
				connection.close()
			}
		}
	})
}

func onNewDataMessage(message as ChatMessage, connection as ChatConnectionHandler)
{
	assert message:
		connection.close()
	var channelId = message.getChannelId()
	if String.isEmpty(channelId) {
		createChannelAndGetId(message, func(newChannelId as string) {
			message.setChannelId(newChannelId)
			getChannel(newChannelId, func(channel as ChatChannel) {
				assert channel:
					connection.close()
				channel.onNewDataMessage(message)
			})
		})
		return
	}
	getChannel(channelId, func(channel as ChatChannel) {
		assert channel:
			connection.close()
		channel.onNewDataMessage(message)
	})
}

func createChannelAndGetId(message as ChatMessage, callback as function<void, string>) private
{
	assert message:
		callback(null)
	checkRecipients(message.getRecipients(), func(valid as bool) {
		assert valid {
			logError("No recipients or recipient count is less than two returned by checkRecipients() method.")
			callback(null)
		}
		createChannel(message, func(channel as ChatChannel) {
			assert channel {
				logError("No ChatChannel instance returned by createChannel() abstract method.")
				callback(null)
			}
			var channelId = channel.getChannelId()
			assert String.isNotEmpty(channelId) {
				logError("Created ChatChannel instance returned by createChannel() abstract method doesn't have channelId.")
				callback(null)
			}
			logDebug("New channel '" .. channelId .. "' created")
			callback(channelId)
		})
	})
}

func broadcastMessage(message as ChatMessage)
{
	assert message
	var recipients = message.getRecipients()
	checkRecipients(recipients, func(valid as bool) {
		assert valid:
			logError("No recipients or recipient count is less than two returned by checkRecipients() method.")
		getUsersForUserIds(recipients, null, func(users as DynamicVector) {
			assert users && users.getSize() > 1:
				logError("No recipients or recipient count is less than two returned by getUsersForUserIds() method.")
			foreach user as ChatUser in users.toVector() {
				assert user:
					logError("Invalid recipient with userId: '" .. user.getUserId() .. "'. Stopping broadcast message.")
				if not user.isOnline() {
					logDebug("User: '" .. user.getUserId() .. "' is offline with last active on: " .. String.forLongInteger(user.getLastActive()) .. ". Sending notification instead.")
					if message.getMessageType() == ChatMessage.DATA_TYPE:
						notifyUserForNewDataMessage(user, message)
					continue
				}
				var brokenConnections = new vector<string>
				foreach connectionId as string in user.getConnectionIds() {
					var connection = user.getConnection(connectionId)
					if not connection {
						brokenConnections += connectionId
						continue
					}
					var r = connection.sendMessage(message)
					if r < 1:
						brokenConnections += connectionId
				}
				foreach connectionId as string in brokenConnections:
					user.removeConnectionForId(connectionId)
				if not user.isOnline() {
					logDebug("User: '" .. user.getUserId() .. "' is offline with last active on: " .. String.forLongInteger(user.getLastActive()) .. ". Sending notification instead.")
					if message.getMessageType() == ChatMessage.DATA_TYPE:
						notifyUserForNewDataMessage(user, message)
					continue
				}
			}
		})
	})
}

func getUsersForUserIds(userIds as DynamicVector, users as DynamicVector, callback as function<void, DynamicVector>) private
{
	if not userIds || userIds.getSize() < 1 {
		callback(users)
		return
	}
	var userId = userIds.get(0) as string
	assert String.isNotEmpty(userId):
		callback(users)
	userIds.remove(0)
	getUser(userId, func(user as ChatUser) {
		assert user:
			callback(users)
		var list = users
		if not list:
			list = new DynamicVector()
		list.append(user)
		getUsersForUserIds(userIds, list, callback)
	})
}
