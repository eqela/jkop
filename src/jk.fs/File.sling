
/*
 * This file is part of Eqela Jkop
 * Copyright (c) 2016-2023 J42 Pte Ltd
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import jk.os
import jk.io

**
** The File class is used to access and manipulate the filesystem of the current
** environment. Despite the name of the class, this class is used to manipulate
** all kinds of filesystem entries, including files, directories, symbolic links,
** block devices, etc., depending on the underlying platform.
**

class is StringObject abstract:

**
** Convert or cast the given parameter object to a File object. Returns null
** if conversion is not possible.
**

func tryAsFile(o as dynamic) static as this
{
	assert o
	if o is this:
		return o as! this
	var ss = String.asString(o)
	if ss:
		return tryForPath(ss)
	return null
}

**
** Convert or cast the given parameter object to a File object. Throws an
** exception if conversion is not possible.
**

func asFile(o as dynamic) static as this
{
	var v = tryAsFile(o)
	if not v:
		Error.throw("notFileObject", o)
	return v
}

**
** Convert or cast the given parameter object to a vector of File objects. Returns
** null if the conversion is not possible.
**

func tryAsFileVector(o as dynamic) static as vector<File>
{
	var it = assert DynamicObject.iterate(o)
	var v = new vector<File>
	loop {
		var oo = it.next()
		if not oo:
			break
		var ff = tryAsFile(oo)
		if ff:
			v += ff
	}
	return v
}

**
** Convert or cast the given parameter object to a vector of File objects. Throws
** an exception if the conversion is not possible.
**

func asFileVector(o as dynamic) static as vector<File>
{
	var it = DynamicObject.iterate(o)
	if not it:
		Error.throw("notIterateable", o)
	var v = new vector<File>
	loop {
		var oo = it.next()
		if not oo:
			break
		var ff = asFile(oo)
		if ff:
			v += ff
	}
	return v
}

**
** Creates a new instance of the File object, representing the given path,
** utilizing the path naming notation of the underlying platform. Essentially,
** this means that a path name like "C:\Users\Me\this.txt" would be valid on Windows,
** and a path name like "/home/me/this.txt" would be valid on a Unix-like
** operating system, such as macOS or Linux. Returns null in case of errors.
**

func tryForPath(path as string) static as this
{
	if path == null || String.getLength(path) < 1:
		return null
	IFDEF "target_java" {
		return FileForJava.forPath(path)
	}
	ELSE IFDEF "target_netx" {
		return FileForDotNet.forPath(path)
	}
	ELSE IFDEF "target_objc" {
		return FileForObjC.forPath(path)
	}
	ELSE IFDEF "target_nodejs" {
		return FileForNodeJS.forPath(path)
	}
	ELSE IFDEF "target_sushi" {
		return FileForSushi.forPath(path)
	}
	ELSE IFDEF "target_kotlin" {
		return FileForKotlin.forPath(path)
	}
	ELSE IFDEF "target_swift" {
		return FileForSwift.forPath(path)
	}
	ELSE IFDEF "target_browser" {
		return FileForBrowser.forPath(path)
	}
	ELSE {
		ERROR "Not implemented."
		return null
	}
}

**
** Creates a new instance of the File object, representing the given path,
** utilizing the path naming notation of the underlying platform. Essentially,
** this means that a path name like "C:\Users\Me\this.txt" would be valid on Windows,
** and a path name like "/home/me/this.txt" would be valid on a Unix-like
** operating system, such as macOS or Linux. Throws an exception in case of errors.
**

func forPath(path as string) static as this
{
	var v = tryForPath(path)
	if not v:
		Error.throw("invalidPath", path)
	return v
}

**
** Creates a new instance of the File object for the given path and keeps the given path.
** While the forPath() method will attempt to follow symbolic links, this method does not
** and will preserve the given path even if it points to a symbolic link rather than the
** actual file.
**

func forRawPath(path as string) static as this
{
	IFDEF "target_sushi" {
		return FileForSushi.forRawPath(path)
	}
	ELSE {
		return forPath(path)
	}
}

**
** Creates a new instance of the File object, representing the given path that can
** be found inside (or relative to) the given "relativeTo" file object. Eg. if you pass
** a path value "test.txt" and a relativeTo file instance representing the directory
** "C:\Users\Me", the created file object would now be representative of "C:\Users\Me\test.txt".
** This function can support both Windows-style (backslash) and Unix-style (forward
** slash) pathname notations: Forward-slash notation always works automatically on
** all platforms, and backslash-notation on Windows-based platforms. To support 
** backslash-notation on non-Windows-platforms, supply "true" as the value for
** the "alwaysSupportWindowsPathnames" parameter. Throws an exception in case of errors.
**

func forRelativePath(path as string, relativeTo as this, alwaysSupportWindowsPathnames as bool = false) static as this
{
	if relativeTo == null:
		return forPath(path)
	if path == null:
		Error.throw("invalidPath", path)
	if PathInfo.isAbsolutePath(path):
		return forPath(path)
	var sep = PathInfo.getPathSeparator()
	// Trick here: This way we can support forward slashes even on Windows
	if sep != '/' {
		if String.getIndexOfCharacter(path, sep) < 0 && String.getIndexOfCharacter(path, '/') >= 0:
			sep = '/'
	}
	else {
		// Trick here: This way we can support backslashes even on non-Windows
		if alwaysSupportWindowsPathnames {
			if String.getIndexOfCharacter(path, sep) < 0 && String.getIndexOfCharacter(path, '\\') >= 0:
				sep = '\\'
		}
	}
	var f = relativeTo
	var comps = String.split(path, sep)
	foreach comp in comps {
		if String.isEmpty(comp):
			continue
		f = f.entry(comp)
	}
	return f
}

**
** Returns a new file object that represents a file with a given name that is
** inside the directory represented by the current object. NOTE: The given file
** name should not include file separator characters (either backslash or forward
** slash, depending on the current platform). Rather, to access nested directories,
** one should call entry() multiple times. Eg. not like this: myDir.entry("a/b/c"),
** but like this: myDir.entry("a").entry("b").entry("c")
**

func entry(name as string) virtual abstract as this

**
** Returns a new file object that represents a file with a given name that is
** inside the directory represented by the current object, very much like the similar
** entry() method. However, while entry() will try to follow symbolic links, this method
** does not, and rather keeps the given filename as is, without modifications.
**

func rawEntry(name as string) virtual as this:
	return entry(name)

**
** Returns an Iterator object that represents all filesystem entries inside the
** directory represented by the current object. Each entry given by the Iterator
** represents a file or directory that was found inside the directory.
**

func entries virtual abstract as Iterator<this>

**
** Moves the filesystem entry represented by the current object to a new location
** that is represented by the "dest" parameter. If "replace" is "true", then any
** existing filesystem entry will be deleted and replaced with the current one.
** Otherwise an error status will occur.
**

func move(dest as this, replace as bool) virtual abstract

**
** Touches the currently represented filesystem entry. This means: If the entry
** currently exists, then its "last modified" timestamp value will be updated to
** reflect the current time. Otherwise, the entry is created. In either case, the
** modification timestamp will reflect the current time after this operation.
**

func touch virtual abstract

**
** Starts reading the contents of the file, and returns a FileReader object that
** can be used to access the contents.
**

func read virtual abstract as FileReader

**
** Starts writing to the contents of the file, and returns a FileWriter object that
** can be used to perform write operations. This method always truncates the file
** if it has existing contents.
**

func write virtual abstract as FileWriter

**
** Starts writing to the contents of the file, and returns a FileWriter object that
** can be used to perform write operations. If the file has existing contents, they
** will be preserved, and any contents written using the FileWriter object will be
** appended to the existing contents.
**

func append virtual abstract as FileWriter

**
** Queries for detailed information about the file, and returns a FileInfo object
** that can be used to access the information. NOTE: This method will always return
** a valid FileInfo object (never a null value). To test if a file exists, call
** the exists() method of the returned object.
**

func stat virtual abstract as FileInfo

**
** Creates a new directory on the filesystem using the path represented by the
** current object. If any parent directory is not yet existing, this method will
** fail. To automatically create also parent directories, see createDirectoryRecursive()
**

func createDirectory virtual abstract

**
** Creates a new directory on the filesystem using the path represented by the
** current object. Will also create all parent directories that may not yet
** be existing.
**

func createDirectoryRecursive virtual abstract

**
** Removes the directory represented by the current object. If the filesystem
** entry does not exist or is not a directory, this method will fail.
**

func removeDirectory virtual abstract

**
** Gets a string representation of the fully qualified pathname that this File
** object represents.
**

func getPath virtual abstract as string

**
** Removes the file or other non-directory filesystem entry that this object points
** to. If the entry does not exist or is a directory, this method will fail.
**

func remove virtual abstract

**
** Makes the current file executable, if possible with regards to the semantics
** of the underlying platform. In practice, this means setting the +x (executable)
** attribute on Unix-like operating systems.
**

func makeExecutable virtual abstract

**
** Gets a string representation of the pathname that this File object represents.
** The returned string is returned as relative to the base directory that is
** given as a parameter (if this file is indeed inside the base directory) or null
** if this file is not inside the given directory. If the prefix parameter is not null,
** then any occurrence of the base directory in the beginning of the path will be
** replaced with the contents of the prefix parameter.
**

func getRelativePath(baseFile as this, prefix as string) virtual as string
{
	if not baseFile:
		Error.throw("noBaseFile", null)
	var vp = getPath()
	var bp = baseFile.getPath()
	while String.endsWith(bp, "/") || String.endsWith(bp, "\\"):
		bp = String.getSubString(bp, 0, String.getLength(bp) - 1)
	if String.startsWith(vp, bp .. "/") || String.startsWith(vp, bp .. "\\") {
		if prefix:
			return prefix .. String.getEndOfString(vp, String.getLength(bp))
		return String.getEndOfString(vp, String.getLength(bp) + 1)
	}
	return null
}

**
** Gets a string representation of the pathname that this File object represents.
** The returned string is returned as relative to the base directory that is
** given as a parameter (if this file is indeed inside the base directory) or only
** the basename of the file if this file is not inside the given directory. If the
** prefix parameter is not null, then any occurrence of the base directory in the
** beginning of the path will be replaced with the contents of the prefix parameter.
**

func getRelativePathOrBasename(baseFile as this, prefix as string) virtual as string
{
	var v = getRelativePath(baseFile, prefix)
	if v:
		return v
	return getBasename()
}

**
** Renames the current filesystem entry, and changes its name to the string
** given as parameter "newname". If a filesystem entry with that name already
** exists and "replace" parameter is "true", then the existing entry will be
** replaced with the current entry.
**

func rename(newname as string, replace as bool) virtual:
	move(forRelativePath(newname, getParent()), replace)

**
** Writes to the current file, getting the contents from the given reader object.
** This will read from the reader until EOF (until read() returns less than 1), and writes
** all contents to the current file. If doAppend is not true, the contents of the
** current file will be truncated prior to writing.
**

func writeFromReader(reader as Reader, doAppend as bool) virtual
{
	assert reader
	var buffer = malloc 1024
	var writer as FileWriter
	if doAppend {
		writer = append()
	}
	else {
		writer = write()
	}
	loop {
		var r = reader.read(buffer)
		if r < 1:
			break
		var w = writer.write(buffer, r)
		if w < r {
			writer.close()
			Error.throw("failedToWriteToFile", this)
		}
	}
	writer.close()
}

**
** Creates a filesystem entry for the currently repre.issented object as a special
** "FIFO" type file (first in, first out) on platforms that support it (which
** are generally Unix-like operating systems).
**

func createFifo virtual:
	Error.throw("notSupported", "File.createFifo")

**
** Returns true if the file represented by the current object is possible to be
** executed on the current platform (ie. if a ProcessLauncher instance can be
** used to execute the file). Eg. on Windows, this would be dependent on the file
** name extension, and on Unix-based platforms, would be depenedent on the
** "execute" flag on the file attributes.
**

func isExecutable virtual as bool
{
	IFDEF "target_browser" {
		return false
	}
	ELSE IFDEF "target_android" {
		return stat().getExecutable()
	}
	ELSE IFDEF "target_darwin" {
		return stat().getExecutable()
	}
	ELSE {
		if OS.isWindows():
			return hasExtension("exe") || hasExtension("bat") || hasExtension("cmd") || hasExtension("com")
		return stat().getExecutable()
	}
}

**
** Checks if the filesystem entry represented by the current object is existing
** in the filesystem. This method returns true if any type of filesystem entry
** exists, whether it is a file, directory, or some other type of entry.
**

func exists virtual as bool
{
	var fi = stat()
	return fi.getType() != FileInfo.FILE_TYPE_UNKNOWN
}

**
** Checks if the contents of the current file and the one given as parameter are
** completely matching (byte per byte comparison).
**

func isIdentical(file as this) virtual as bool
{
	assert file
	assert exists()
	assert file.exists()
	var myrd = read()
	var oord = file.read()
	var mybuf = malloc 1024
	var oobuf = malloc 1024
	var v = true
	while v {
		var myr = myrd.read(mybuf)
		var oor = oord.read(oobuf)
		if myr != oor {
			v = false
		}
		else {
			if myr < 1:
				break
			for(var n=0; n<myr; n++) {
				IFDEF "target_objc" {
					if Buffer.getByte(mybuf, n) != Buffer.getByte(oobuf, n):
						v = false
				}
				ELSE IFDEF "target_kotlin" {
					v = lang "kotlin" bool {{{ if (mybuf!!.get(n) != oobuf!!.get(n)) false else true }}}
				}
				ELSE {
					if mybuf[n] != oobuf[n] {
						v = false
					}
				}
			}
		}
	}
	myrd.close()
	oord.close()
	return v
}

class ReadLineIterator is Iterator<string>
{
	pvar reader as PrintReader

	func next as string
	{
		assert reader
		var v = reader.readLine()
		if v == null {
			reader.close()
			reader = null
		}
		return v
	}

	func hasNext as bool
	{
		assert reader
		return not reader.hasEnded()
	}
}

**
** Reads the complete file contents, treats the contents as a UTF-8 encoded file,
** and returns the complete contents as an Iterator that returns a series of strings,
** each string representing one line of text in the file. The line delimiter character
** '\n' determines where the lines are separated.
**

func readLines as Iterator<string>
{
	var rd = PrintReader.forReader(read())
	return new ReadLineIterator().setReader(rd)
}

**
** Reads the complete file contents, treats the contents as a UTF-8 encoded file,
** and returns the complete conents as a vector of strings, each string representing
** one line of text in the file. The line delimiter character '\n' determines where
** the lines are separated.
**

func readLinesVector as vector<string>
{
	var it = readLines()
	var v = new vector<string>
	loop {
		var line = it.next()
		if not line:
			break
		v += line
	}
	return v
}

**
** Checks if the file has been modified since the given timestamp.
**

func hasChangedSince(originalTimeStamp as long) as bool
{
	var nts = getLastModifiedTimeStamp()
	if nts > originalTimeStamp:
		return true
	return false
}

**
** Gets the last modification timestamp of this file as a Unix timestamp (number
** of seconds since January 1, 1970).
**

func getLastModifiedTimeStamp as long
{
	if isFile() == false:
		return 0
	var st = stat()
	if st == null:
		return 0
	return st.getModifyTime() as long
}

**
** Compares the last modification time of the current object to that of the other
** object given as parameter. Returns -1 if the current file was modified prior to
** that given as parameter, 0 if the modification timestamps of both files are equals,
** or 1 if the current file was modified after that given as parameter.
**

func compareModificationTime(bf as this) virtual as int
{
	if bf == null:
		return 1
	var myts = getLastModifiedTimeStamp()
	var bfts = bf.getLastModifiedTimeStamp()
	if myts < bfts:
		return -1
	if myts > bfts:
		return 1
	return 0
}

**
** Checks if this file is newer than the one specified as a parameters (compares
** the modification timestamps of the two files).
**

func isNewerThan(bf as this) virtual as bool:
	return compareModificationTime(bf) > 0

**
** Checks if this file is older than the one specified as a parameters (compares
** the modification timestamps of the two files).
**

func isOlderThan(bf as this) virtual as bool:
	return compareModificationTime(bf) < 0

**
** Checks if this file represents the same file as the one given as parameter.
** NOTE: This checks if the two objects are referencing the same exact file. This
** does not compare the contents of the files (for that, use isIdentical()).
**

func isSame(file as this) virtual as bool
{
	assert file
	var path = getPath()
	if path && path == file.getPath():
		return true
	return false
}

**
** Removes the filesystem entry that is referenced by this object, including any
** children, contained files or subdirectories it may have.
**

func removeRecursive virtual
{
	var finfo = stat()
	if finfo.isDirectory() == false || finfo.isLink() == true {
		remove()
		return
	}
	var it = entries()
	while it {
		var f = it.next()
		if not f:
			break
		f.removeRecursive()
	}
	removeDirectory()
}

**
** Returns true if this object points to an existing file on the filesystem.
**

func isFile virtual as bool
{
	var st = stat()
	return st.isFile()
}

**
** Returns true if this object points to an existing directory on the filesystem.
**

func isDirectory virtual as bool
{
	var st = stat()
	return st.isDirectory()
}

**
** Returns true if this object points to an existing symbolic link on the filesystem
** (if symbolic links are at all supported on the current operating system).
**

func isLink virtual as bool
{
	var st = stat()
	return st.isLink()
}

**
** Returns the size in bytes of the current file.
**

func getSize virtual as int
{
	var st = stat()
	return st.getSize()
}

**
** Sets the mode permissions of this file. The implementation and functionality
** of this is system-dependent, and generally would refer to the Unix style
** permission flags.
**

func setMode(mode as int) virtual:
	ERROR "Not implemented"

**
** Sets the user id (uid) of the owner of this file. Only applicable if the underlying
** platform supports numerical user ids (usually Unix-like operating systems).
**

func setOwnerUser(uid as int) virtual:
	ERROR "Not implemented"

**
** Sets the group id (gid) of the owner of this file. Only applicable if the underlying
** platform supports numerical group ids (usually Unix-like operating systems).
**

func setOwnerGroup(gid as int) virtual:
	ERROR "Not implemented"

**
** Returns a new file object that represents the same path as the current object,
** but with a given filename extension added to the file name. Eg. the following
** would be true: File.forPath("super").withExtension("txt") = "super.txt".
**

func withExtension(ext as string) virtual as this
{
	if not ext:
		return this
	var bn = getBasename()
	return getSibling(bn .. "." .. ext)
}

**
** Returns a new file object that represents the same path as the current object,
** but converted into executable format of the same, if applicable. In practice,
** this adds the executable filename extension "exe", "com", "bat" or "cmd" on a Windows
** based platform, if such a file exists. While this would have no effect on a
** Unix-like operating system, you can use this for cross platform compatibility
** between Windows and other operating systems.
**

func asExecutable virtual as this
{
	IFDEF "target_android" {
		return this
	}
	ELSE IFDEF "target_darwin" {
		return this
	}
	ELSE IFDEF "target_browser" {
		return this
	}
	ELSE {
		if OS.isWindows() {
			if hasExtension("exe") == false && hasExtension("bat") == false && hasExtension("cmd") == false && hasExtension("com") == false {
				var exe = withExtension("exe")
				if exe.isFile():
					return exe
				var bat = withExtension("bat")
				if bat.isFile():
					return bat
				var cmd = withExtension("cmd")
				if cmd.isFile():
					return cmd
				var com = withExtension("com")
				if com.isFile():
					return com
				return exe
			}
		}
		return this
	}
}

**
** Returns the parent directory of the currently referenced file or directory.
**

func getParent virtual as this
{
	var path = directoryName()
	if path == null:
		Error.throw("noDirectoryName", this)
	return forPath(path)
}

**
** Returns a new file object that references another file in the same directory
** as the current one, but with a different name, as supplied in the parameter.
** If name is null, then returns the parent directory.
**

func getSibling(name as string) virtual as this
{
	var pp = getParent()
	if name == null:
		return pp
	return pp.entry(name)
}

**
** Checks if this filename has the given extension.
** Eg. File.forPath("test.exe").hasExtension("exe") would return true.
**

func hasExtension(ext as string) virtual as bool
{
	var xx = assert extension()
	return String.equalsIgnoreCase(xx, ext)
}

**
** Returns the filename extension (if any) of the current file as a string.
** Eg. File.forPath("test.exe").extension() would return "exe". Returns null
** if the file has no extension.
**

func extension virtual as string
{
	var bn = assert getBasename()
	var dot = String.getLastIndexOfCharacter(bn, '.')
	if dot < 0:
		return null
	return String.getEndOfString(bn, dot+1)
}

**
** Returns the name of the directory (as a string) where the current file is in.
**

func directoryName virtual as string
{
	var path = getPath()
	var delim = PathInfo.getPathSeparator()
	var dp = String.getLastIndexOfCharacter(path, delim)
	if delim != '/' {
		var sdp = String.getLastIndexOfCharacter(path, '/')
		if sdp > dp:
			dp = sdp
	}
	if dp < 0:
		return "."
	return String.getSubString(path, 0, dp)
}

**
** Returns the name of the current file, excluding the directory path.
**

func getBasename virtual as string
{
	var path = getPath()
	var delim = PathInfo.getPathSeparator()
	if String.endsWith(path, String.forCharacter(delim)):
		path = String.getSubString(path, 0, String.getLength(path) - 1)
	if delim != '/' && String.endsWith(path, "/"):
		path = String.getSubString(path, 0, String.getLength(path) - 1)
	var dp = String.getLastIndexOfCharacter(path, delim)
	if delim != '/' {
		var sdp = String.getLastIndexOfCharacter(path, '/')
		if sdp > dp:
			dp = sdp
	}
	if dp < 0:
		return path
	return String.getEndOfString(path, dp+1)
}

**
** Returns the name of the current file, excluding the directory path and also
** excluding the file extension, if any.
**

func getBasenameWithoutExtension virtual as string
{
	var bn = getBasename()
	var dot = String.getLastIndexOfCharacter(bn, '.')
	if dot < 0:
		return bn
	return String.getSubString(bn, 0, dot)
}

**
** Copies the currently referenced file to a new given file, defined by the "dest" parameter.
** NOTE: As the name suggests, this does not copy directories. This method is intended solely
** to copy an individual file.
**

func copyFileTo(dest as this)
{
	if not dest:
		Error.throw("noDestinationFile", null)
	if this.isSame(dest):
		return
	var reader as FileReader
	var writer as FileWriter
	try {
		var buf = malloc (4096 * 4)
		var reader = this.read()
		var writer = dest.write()
		var n = 0
		while (n = reader.read(buf)) > 0 {
			var nr = writer.write(buf, n)
			if nr != n {
				dest.remove()
				Error.throw("failedToWriteAllBytes", null)
			}
		}
		var fi = this.stat()
		var mode = fi.getMode()
		if mode != 0:
			dest.setMode(mode)
	}
	catch e {
		throw e
	}
	finally {
		if reader && reader is Closable:
			(reader as! Closable).close()
		if writer && writer is Closable:
			(writer as! Closable).close()
	}
}

**
** Copies the currently referenced File object (which may be either a file or a
** directory) to a new given target path, defined by the "dest" parameter.
**

func copyFileOrDirectoryTo(dest as this)
{
	if not dest:
		Error.throw("noDestinationFile", null)
	if isFile() {
		copyFileTo(dest)
		return
	}
	if isDirectory() {
		dest.createDirectoryRecursive()
		var it = entries()
		loop {
			var nsrc = it.next()
			if not nsrc:
				break
			var ndest = dest.entry(nsrc.getBasename())
			nsrc.copyFileOrDirectoryTo(ndest)
		}
		return
	}
	Error.throw("notFileOrDirectory", this)
}

**
** Truncates and replaces the contents of the given filesystem entry. after
** successful completion, the contents of the "str" variable will become the
** new contents of the file. The file contents will be encoded using the character
** encoding specified.
**

func setContentsString(str as string, encoding as string) virtual
{
	if String.isEmpty(encoding):
		Error.throw("noEncoding", encoding)
	setContentsBuffer(String.toBuffer(str, encoding))
}

**
** Truncates and replaces the contents of the given filesystem entry. after
** successful completion, the contents of the "str" variable will become the
** new contents of the file, encoded using the UTF-8 character encoding.
**

func setContentsUTF8(str as string) virtual:
	setContentsBuffer(String.toUTF8Buffer(str))

**
** Truncates and replaces the contents of the given filesystem entry. after
** successful completion, the contents of the "buffer" variable will become the
** new contents of the file.
**

func setContentsBuffer(buffer as buffer) virtual
{
	var writer = write()
	if buffer {
		var sz = (sizeof buffer) as int
		if writer.write(buffer, sz) < sz {
			writer.close()
			Error.throw("failedToWriteAllBytes", this)
		}
	}
	writer.close()
}

**
** Reads the entire contents of the file and returns them as a string object.
** The file contents are decoded using the specified character encoding.
**

func getContentsString(encoding as string) virtual as string
{
	if String.isEmpty(encoding):
		Error.throw("noEncoding", encoding)
	var b = getContentsBuffer()
	if not b {
		if isFile() && getSize() == 0:
			return ""
		Error.throw("failedToReadFileContents", this)
	}
	return String.forBuffer(b, encoding)
}

**
** Reads the entire contents of the file and returns them as a string object.
** The file contents are decoded using the UTF-8 character encoding. If the file
** does not exist or if any other error is encountered, this method throws an error.
**

func getContentsUTF8 virtual as string
{
	var b = getContentsBuffer()
	if not b {
		if isFile() && getSize() == 0:
			return ""
		Error.throw("failedToReadFileContents", this)
	}
	return String.forUTF8Buffer(b)
}

**
** Reads the entire contents of the file and returns them as a string object.
** The file contents are decoded using the UTF-8 character encoding. If the file
** does not exist or if any other error is encountered, this method returns null.
**

func tryGetContentsUTF8 virtual as string
{
	try {
		return getContentsUTF8()
	}
	catch e {
	}
	return null
}

**
** Reads the entire contents of the file and returns them as a buffer object. If the file
** does not exist or if any other error is encountered, this method throws an error.
**

func getContentsBuffer virtual as buffer
{
	var reader = read()
	var sz = reader.getSize()
	if sz < 1 {
		reader.close()
		return null
	}
	var b = malloc sz
	var rsz = reader.read(b)
	reader.close()
	if rsz < sz:
		Error.throw("failedToReadFromFile", this)
	return b
}

**
** Reads the entire contents of the file and returns them as a buffer object. If the file
** does not exist or if any other error is encountered, this method returns null.
**

func tryGetContentsBuffer virtual as buffer
{
	try {
		return getContentsBuffer()
	}
	catch e {
	}
	return null
}

**
** Returns the representation of this object as a string.
**

func toString as string:
	return getPath()
