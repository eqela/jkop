
/*
 * This file is part of Jkop
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class:

IFDEF "target_ios"
{
	modifier #typedef
	basetype !"UIView" type extends
	IFDEF "target_objc" {
		depend "objc-header-h:<UIKit/UIKit.h>"
		depend "objc-header-m:<objc/runtime.h>"
		depend "objc-header-m:<UIKit/UIGestureRecognizerSubclass.h>"
	}
	ELSE IFDEF "target_swift" {
		depend "swift-import:UIKit"
		depend "swift-import-class:UIKit.UIGestureRecognizerSubclass"
	}
}

IFDEF "target_macosoc"
{
	modifier #typedef
	basetype !"NSView" type extends
	depend "objc-header-h:<AppKit/AppKit.h>"
}

IFDEF "target_android"
{
	modifier #typedef
	basetype !"android.view.View" type extends
}

IFDEF "target_reactjs"
{
	modifier #typedef
	basetype !"React.Component" type extends
	depend "js:React:react"
}

IFDEF "target_html"
{
	import cave
	import cape

	var element public as object
	var cachedWidth public as int
	var cachedHeight public as int

	ctor
	{
		element = createElement()
		lang "js" {{{
			this.element.widgetObject = this;
		}}}
		prepareElement(element)
	}

	func createElement virtual as object:
		return HTMLDOM.createElement("div")

	func prepareElement(element as object) virtual
	{
		HTMLDOM.setStyle(element, "pointer-events", "auto")
		HTMLDOM.setStyle(element, "position", "absolute")
		HTMLDOM.setStyle(element, "overflow", "hidden")
	}
}

IFDEF "target_uwp"
{
	modifier #typedef
	basetype !"Windows.UI.Xaml.UIElement" type extends

	class MyWidgetInfo public
	{
		var x public = 0.0 as float
		var y public = 0.0 as float
		var w public = 0.0 as float
		var h public = 0.0 as float
	}

	lang "cs" {{{
		public static readonly Windows.UI.Xaml.DependencyProperty WidgetProperty = Windows.UI.Xaml.DependencyProperty.RegisterAttached(
			"Widget",
			typeof(MyWidgetInfo),
			typeof(Widget),
			new Windows.UI.Xaml.PropertyMetadata(null)
		);
	}}}

	func getMyWidgetInfo(widget as this) static as MyWidgetInfo
	{
		assert widget
		var v = lang "cs" object {{{ widget.GetValue(WidgetProperty) }}} as MyWidgetInfo
		if not v {
			v = new MyWidgetInfo()
			lang "cs" {{{
				widget.SetValue(WidgetProperty, v);
			}}}
		}
		return v
	}

	func arrangeWidget(widget as this) static
	{
		var wi #used = getMyWidgetInfo(widget)
		lang "cs" {{{
			widget.Arrange(new Windows.Foundation.Rect(wi.x, wi.y, wi.w, wi.h));
		}}}
	}
}

func onWidgetAddedToParent(widget as this) static
{
	assert widget
	if widget is ParentAwareWidget:
		(widget as! ParentAwareWidget).onWidgetAddedToParent()
}

func onWidgetRemovedFromParent(widget as this) static
{
	assert widget
	if widget is ParentAwareWidget:
		(widget as! ParentAwareWidget).onWidgetRemovedFromParent()
}

func notifyOnStartScreen(widget as this, screen as ScreenForWidget) static
{
	foreach child in getChildren(widget):
		notifyOnStartScreen(child, screen)
	if widget is ScreenStartStopAwareWidget:
		(widget as! ScreenStartStopAwareWidget).onStartScreen(screen)
}

func notifyOnStopScreen(widget as this, screen as ScreenForWidget) static
{
	foreach child in getChildren(widget):
		notifyOnStopScreen(child, screen)
	if widget is ScreenStartStopAwareWidget:
		(widget as! ScreenStartStopAwareWidget).onStopScreen(screen)
}

func notifyOnAddedToScreen(widget as this, screen as ScreenForWidget) static
{
	foreach child in getChildren(widget):
		notifyOnAddedToScreen(child, screen)
	if widget is ScreenAwareWidget:
		(widget as! ScreenAwareWidget).onWidgetAddedToScreen(screen)
}

func notifyOnRemovedFromScreen(widget as this, screen as ScreenForWidget) static
{
	if widget is ScreenAwareWidget:
		(widget as! ScreenAwareWidget).onWidgetRemovedFromScreen(screen)
	foreach child in getChildren(widget):
		notifyOnRemovedFromScreen(child, screen)
}

func addChild(parent as this, child as this) static
{
	assert parent
	assert child
	if child is ParentAwareWidget:
		(child as! ParentAwareWidget).onWidgetAddingToParent()
	IFDEF "target_ios" {
		IFDEF "target_objc" {
			lang "objc" {{{
				[parent addSubview:child];
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				parent.addSubview(child!)
			}}}
		}
	}
	ELSE IFDEF "target_android" {
		var vg = assert parent as !"android.view.ViewGroup"
		IFDEF "target_java" {
			lang "java" {{{
				vg.addView(child);
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				vg!!.addView(child)
			}}}
		}
	}
	ELSE IFDEF "target_html" {
		HTMLDOM.appendChild(parent.element, child.element)
	}
	ELSE IFDEF "target_uwp" {
		if parent is !"Windows.UI.Xaml.Controls.Panel" {
			var panel = parent as! !"Windows.UI.Xaml.Controls.Panel"
			lang "cs" {{{
				panel.Children.Add(child);
			}}}
		}
		else if parent is !"Windows.UI.Xaml.Controls.UserControl" {
			var uc = parent as! !"Windows.UI.Xaml.Controls.UserControl"
			lang "cs" {{{
				var ucc = uc.Content as Windows.UI.Xaml.Controls.ContentControl;
				if(ucc != null) {
					ucc.Content = child;
				}
			}}}
		}
		else {
			ERROR "Unsupported parent type when adding a child widget"
		}
	}
	ELSE {
		ERROR "Not implemented."
	}
	var pp = parent as ContainerWidget
	if pp:
		pp.onChildWidgetAdded(child)
	onWidgetAddedToParent(child)
	var screen = ScreenForWidget.findScreenForWidget(child)
	if screen:
		notifyOnAddedToScreen(child, screen)
}

func removeFromParent(child as this) static as this
{
	assert child
	var parentWidget = assert getParent(child)
	var pp = parentWidget as ContainerWidget
	IFDEF "target_ios" {
		IFDEF "target_objc" {
			lang "objc" {{{
				[child removeFromSuperview];
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				child.removeFromSuperview()
			}}}
		}
	}
	ELSE IFDEF "target_android" {
		if parentWidget != null && parentWidget is !"android.view.ViewGroup" {
			(parentWidget as! !"android.view.ViewGroup").removeView(child)
		}
	}
	ELSE IFDEF "target_html" {
		HTMLDOM.remove(child.element)
	}
	ELSE {
		ERROR "Not implemented."
	}
	if pp {
		var v = new vector<this>
		v += child
		pp.onChildWidgetsRemoved(v)
	}
	var screen = ScreenForWidget.findScreenForWidget(parentWidget)
	if screen:
		notifyOnRemovedFromScreen(child, screen)
	onWidgetRemovedFromParent(child)
	return null
}

IFDEF "target_html"
{
	func domElementAsWidget(element as object) static as this
	{
		var v as this = null
		lang "js" {{{
			v = element.widgetObject;
		}}}
		if(v is this == false) {
			v = null
		}
		return v
	}
}

func hasParent(widget as this) static as bool
{
	assert getParent(widget)
	return true
}

func getParent(widget as this) static as this
{
	assert widget
	IFDEF "target_ios" {
		if widget is ContainerWidget && (widget as! ContainerWidget).getScreenForWidget():
			return null
		IFDEF "target_objc" {
			return lang "objc" this {{{ [widget superview] }}}
		}
		ELSE IFDEF "target_swift" {
			return lang "swift" this {{{ widget.superview }}}
		}
	}
	ELSE IFDEF "target_android" {
		var v as this = null
		IFDEF "target_java" {
			lang "java" {{{
				android.view.ViewParent vp = widget.getParent();
				if(vp != null && vp instanceof android.view.ViewGroup) {
					v = (android.view.ViewGroup)vp;
				}
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				var vp : android.view.ViewParent? = widget!!.getParent()
				if(vp != null && vp is android.view.ViewGroup) {
					v = (vp as? android.view.ViewGroup)
				}
			}}}
		}
		return v
	}
	ELSE IFDEF "target_html" {
		var pe = assert HTMLDOM.getParentElement(widget.element)
		return domElementAsWidget(pe)
	}
	ELSE IFDEF "target_uwp" {
		var fwe = assert widget as !"Windows.UI.Xaml.FrameworkElement"
		var v as this
		lang "cs" {{{
			v = fwe.Parent as Windows.UI.Xaml.UIElement;
		}}}
		return v
	}
	ELSE {
		ERROR "Not implemented."
		return null
	}
}

func getChildren(widget as this) static as vector<this>
{
	assert widget
	IFDEF "target_ios" {
		var v = new vector<this>
		IFDEF "target_objc" {
			lang "objc" {{{
				for(UIView* subview in widget.subviews) {
					[v addObject:subview];
				}
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				for subview in widget.subviews {
					v.add(subview)
				}
			}}}
		}
		return v
	}
	ELSE IFDEF "target_android" {
		var v = new vector<this>
		IFDEF "target_java" {
			lang "java" {{{
				if(widget instanceof android.view.ViewGroup) {
					android.view.ViewGroup vg = (android.view.ViewGroup)widget;
					int n;
					for(n=0; n<vg.getChildCount(); n++) {
						v.add(vg.getChildAt(n));
					}
				}
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				if(widget is android.view.ViewGroup) {
					var vg : android.view.ViewGroup? = widget as? android.view.ViewGroup
					var n = 0
					for(n in 0..vg!!.getChildCount()) {
						v!!.add(vg!!.getChildAt(n))
					}
				}
			}}}
		}
		return v
	}
	ELSE IFDEF "target_html" {
		var v = new vector<this>
		var dome #used = widget.element
		var ll = lang "js" int {{{ dome.childNodes.length }}}
		for(var n = 0 ; n < ll ; n++):
			v += domElementAsWidget(lang "js" object {{{ dome.childNodes[n] }}})
		return v
	}
	ELSE IFDEF "target_uwp" {
		var cc = assert widget as !"Windows.UI.Xaml.Controls.Panel"
		var v = new vector<this>
		lang "cs" {{{
			foreach(var child in cc.Children) {
				v.Add(child);
			}
		}}}
		return v
	}
	ELSE {
		ERROR "Not implemented."
		return null
	}
}

func getX(widget as this) static as int
{
	if not widget:
		return 0
	var v = 0
	IFDEF "target_ios" {
		IFDEF "target_objc" {
			lang "objc" {{{
				v = widget.frame.origin.x;
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				v = Int(widget.frame.origin.x)
			}}}
		}
	}
	ELSE IFDEF "target_android" {
		IFDEF "target_java" {
			lang "java" {{{
				v = (int)widget.getX();
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				v = widget!!.getX().toInt()
			}}}
		}
	}
	ELSE IFDEF "target_html" {
		lang "js" {{{
			v = widget.element.offsetLeft;
		}}}
	}
	ELSE IFDEF "target_uwp" {
		v = getMyWidgetInfo(widget).x as int
	}
	ELSE {
		ERROR "Not implemented."
	}
	return v
}

func getY(widget as this) static as int
{
	if not widget:
		return 0
	var v = 0
	IFDEF "target_ios" {
		IFDEF "target_objc" {
			lang "objc" {{{
				v = widget.frame.origin.y;
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				v = Int(widget.frame.origin.y)
			}}}
		}
	}
	ELSE IFDEF "target_android" {
		IFDEF "target_java" {
			lang "java" {{{
				v = (int)widget.getY();
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				v = widget!!.getY().toInt()
			}}}
		}
	}
	ELSE IFDEF "target_html" {
		lang "js" {{{
			v = widget.element.offsetTop;
		}}}
	}
	ELSE IFDEF "target_uwp" {
		v = getMyWidgetInfo(widget).y as int
	}
	ELSE {
		ERROR "Not implemented."
	}
	return v
}

func getAbsoluteX(widget as this) static as int
{
	assert widget
	var v = 0
	IFDEF "target_html" {
		lang "js" {{{
			v = widget.element.getBoundingClientRect().left;
		}}}
	}
	ELSE IFDEF "target_android" {
		IFDEF "target_java" {
			lang "java" {{{
				int[] location = new int[2];
				widget.getLocationOnScreen(location);
				v = location[0];
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				var location = IntArray(2)
				widget!!.getLocationOnScreen(location)
				v = location[0]
			}}}
		}
	}
	ELSE IFDEF "target_ios" {
		IFDEF "target_objc" {
			lang "objc" {{{
				CGPoint location = [widget.superview convertPoint:widget.frame.origin toView:nil];
				v = (NSInteger)(location.x);
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				let location : CGPoint = widget.superview!.convert(widget.frame.origin, to:nil)
				v = Int(location.x)
			}}}
		}
	}
	ELSE {
		ERROR "Not implemented"
	}
	return v
}

func getAbsoluteY(widget as this) static as int
{
	assert widget
	var v = 0
	IFDEF "target_html" {
		lang "js" {{{
			v = widget.element.getBoundingClientRect().bottom;
		}}}
	}
	ELSE IFDEF "target_android" {
		IFDEF "target_java" {
			lang "java" {{{
				int[] location = new int[2];
				widget.getLocationOnScreen(location);
				v = location[1];
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				var location = IntArray(2)
				widget!!.getLocationOnScreen(location)
				v = location[1]
			}}}
		}
	}
	ELSE IFDEF "target_ios" {
		IFDEF "target_objc" {
			lang "objc" {{{
				CGPoint location = [widget.superview convertPoint:widget.frame.origin toView:nil];
				v = (NSInteger)(location.y);
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				let location : CGPoint = widget.superview!.convert(widget.frame.origin, to:nil)
				v = Int(location.y)
			}}}
		}
	}
	ELSE {
		ERROR "Not implemented"
	}
	return v
}

func getWidth(widget as this) static as int
{
	if not widget:
		return 0
	var v = 0
	IFDEF "target_ios" {
		IFDEF "target_objc" {
			lang "objc" {{{
				v = widget.frame.size.width;
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				v = Int(widget.frame.size.width)
			}}}
		}
	}
	ELSE IFDEF "target_android" {
		IFDEF "target_java" {
			v = lang "java" int {{{ widget.getWidth(); }}}
		}
		ELSE IFDEF "target_kotlin" {
			v = lang "kotlin" int {{{ widget.getWidth() }}}
		}
	}
	ELSE IFDEF "target_html" {
		if isRootWidget(widget) {
			lang "js" {{{
				v = widget.element.getBoundingClientRect().width;
			}}}
		}
		else {
			v = widget.cachedWidth
		}
	}
	ELSE IFDEF "target_uwp" {
		v = Math.ceil(getMyWidgetInfo(widget).w as double) as int
	}
	ELSE {
		ERROR "Not implemented."
	}
	return v
}

func getHeight(widget as this) static as int
{
	if not widget:
		return 0
	var v = 0
	IFDEF "target_ios" {
		IFDEF "target_objc" {
			lang "objc" {{{
				v = widget.frame.size.height;
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				v = Int(widget.frame.size.height)
			}}}
		}
	}
	ELSE IFDEF "target_android" {
		IFDEF "target_java" {
			v = lang "java" int {{{ widget.getHeight(); }}}
		}
		ELSE IFDEF "target_kotlin" {
			v = lang "kotlin" int {{{ widget.getHeight() }}}
		}
	}
	ELSE IFDEF "target_html" {
		if isRootWidget(widget) {
			lang "js" {{{
				v = widget.element.getBoundingClientRect().height;
			}}}
		}
		else {
			v = widget.cachedHeight
		}
	}
	ELSE IFDEF "target_uwp" {
		v = Math.ceil(getMyWidgetInfo(widget).h as double) as int
	}
	ELSE {
		ERROR "Not implemented."
	}
	return v
}

func getGeometryString(widget as this) static as string
{
	if not widget:
		return "null,null,null,null"
	return String.forInteger(getX(widget)) .. "," .. String.forInteger(getY(widget)) .. "," .. String.forInteger(getWidth(widget)) .. "," .. String.forInteger(getHeight(widget))
}

func move(widget as this, x as int #notLiteral, y as int #notLiteral) static
{
	IFDEF "target_ios" {
		IFDEF "target_objc" {
			lang "objc" {{{
				widget.frame = CGRectMake(x, y, widget.frame.size.width, widget.frame.size.height);
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				widget.frame = CGRect(x: CGFloat(x), y: CGFloat(y), width: widget.frame.size.width, height: widget.frame.size.height)
			}}}
		}
	}
	ELSE IFDEF "target_android" {
		IFDEF "target_java" {
			lang "java" {{{
				widget.layout(x, y, x+widget.getWidth(), y+widget.getHeight());
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				widget!!.layout(x, y, x+widget!!.getWidth(), y+widget!!.getHeight())
			}}}
		}
	}
	ELSE IFDEF "target_html" {
		lang "js" {{{
			widget.element.style.left = (~~x) + "px";
			widget.element.style.top = (~~y) + "px";
		}}}
	}
	ELSE IFDEF "target_uwp" {
		var wi = getMyWidgetInfo(widget)
		wi.x = x as float
		wi.y = y as float
		lang "cs" {{{
			widget.UpdateLayout();
		}}}
	}
	ELSE {
		ERROR "Not implemented."
	}
}

func isRootWidget(widget as this) static as bool
{
	var cw = assert widget as ContainerWidget
	var pp = getParent(cw)
	if not pp:
		return true
	if pp is WidgetWithLayout:
		return false
	return true
}

func findScreen(widget as this) static as Screen
{
	IFDEF "target_ios" {
		var pp = widget
		while pp {
			if pp is ContainerWidget {
				var screen = (pp as! ContainerWidget).getScreenForWidget()
				if screen:
					return screen
			}
			pp = getParent(pp)
		}
		return null
	}
	ELSE IFDEF "target_android" {
		var view #used = widget
		var scr as !"android.app.Activity"
		IFDEF "target_java" {
			lang "java" {{{
				if(view == null) {
					return(null);
				}
				android.content.Context ctx = view.getContext();
				if(ctx != null && ctx instanceof android.app.Activity) {
					scr = (android.app.Activity)ctx;
				}
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				if(view == null) {
					return(null)
				}
				var ctx : android.content.Context = view.getContext()
				if(ctx != null && ctx is android.app.Activity) {
					scr = ctx as? android.app.Activity
				}
			}}}
		}
		return scr as Screen
	}
	ELSE IFDEF "target_html" {
		var pp = widget.element
		while pp {
			var v as object
			lang "js" {{{
				if(pp.screenObject) {
					v = pp.screenObject
				}
			}}}
			if v:
				return v as Screen
			pp = HTMLDOM.getParentElement(pp)
		}
		return null
	}
	ELSE IFDEF "target_uwp" {
		var pp = widget
		while pp {
			if pp is Screen:
				return pp as! Screen
			pp = getParent(pp)
		}
		return null
	}
	ELSE {
		ERROR "Not implemented"
		return null
	}
}

func findRootWidget(widget as this) static as ContainerWidget
{
	var v = widget
	loop {
		if not v:
			break
		if isRootWidget(v):
			return v as ContainerWidget
		v = getParent(v)
	}
	return null
}

func setLayoutSize(widget as this, widthValue as int #notLiteral, heightValue as int #notLiteral) static as bool
{
	if isRootWidget(widget) {
		var ccw = widget as ContainerWidget
		if ccw && ccw.getAllowResize() == false:
			return false
	}
	var width = widthValue
	if width < 0:
		width = 0
	var height = heightValue
	if height < 0:
		height = 0
	if getWidth(widget) == width && getHeight(widget) == height:
		return false
	IFDEF "target_ios" {
		IFDEF "target_objc" {
			lang "objc" {{{
				widget.frame = CGRectMake(widget.frame.origin.x, widget.frame.origin.y, width, height);
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				widget.frame = CGRect(x: widget.frame.origin.x, y: widget.frame.origin.y, width: CGFloat(width), height: CGFloat(height))
			}}}
		}
	}
	ELSE IFDEF "target_android" {
		IFDEF "target_java" {
			lang "java" {{{
				int x = (int)widget.getX();
				int y = (int)widget.getY();
				widget.layout(x, y, x+width, y+height);
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				var x = widget!!.getX().toInt()
				var y = widget!!.getY().toInt()
				widget!!.layout(x, y, x+width, y+height)
			}}}
		}
	}
	ELSE IFDEF "target_html" {
		lang "js" {{{
			widget.element.style.width = ~~width + "px";
			widget.element.style.height = ~~height + "px";
		}}}
		widget.cachedWidth = width
		widget.cachedHeight = height
	}
	ELSE IFDEF "target_uwp" {
		var wi = getMyWidgetInfo(widget)
		wi.w = width as float
		wi.h = height as float
		var fwe = widget as !"Windows.UI.Xaml.FrameworkElement"
		if fwe {
			lang "cs" {{{
				fwe.Width = (double)width;
				fwe.Height = (double)height;
			}}}
		}
	}
	ELSE {
		ERROR "Not implemented."
	}
	if widget is ResizeAwareWidget:
		(widget as! ResizeAwareWidget).onWidgetResized()
	return true
}

func resizeHeight(widget as this, height as int #notLiteral) static as bool
{
	assert setLayoutSize(widget, getWidth(widget), height)
	if widget is HeightAwareWidget:
		(widget as! HeightAwareWidget).onWidgetHeightChanged(height)
	return true
}

func layout(widget as this, widthConstraint as int #notLiteral, force as bool = false) static
{
	assert widget
	var done = false
	if widget is WidgetWithLayout:
		done = (widget as! WidgetWithLayout).layoutWidget(widthConstraint, force)
	if not done {
		IFDEF "target_ios" {
			var srw as int
			var srh as int
			var cw = widthConstraint
			var ch #used = 0
			if cw < 0:
				cw = 0
			IFDEF "target_objc" {
				lang "objc" {{{
					CGSize nsz = [widget sizeThatFits:CGSizeMake(cw, ch)];
					srw = nsz.width;
					if(nsz.width - srw > 0) {
						srw ++;
					}
					srh = nsz.height;
					if(nsz.height - srh > 0) {
						srh ++;
					}
				}}}
			}
			ELSE IFDEF "target_swift" {
				lang "swift" {{{
					let nsz : CGSize = widget.sizeThatFits(CGSize(width: Double(cw), height: Double(ch)))
					srw = Int(nsz.width)
					if (Int(nsz.width) - srw) > 0 {
						srw += 1
					}
					srh = Int(nsz.height)
					if (Int(nsz.height) - srh) > 0 {
						srh += 1
					}
					if widthConstraint >= 0 && srw != widthConstraint {
						srw = widthConstraint
					}
				}}}
			}
			if widthConstraint >= 0 && srw != widthConstraint:
				srw = widthConstraint
			setLayoutSize(widget, srw, srh)
		}
		ELSE IFDEF "target_android" {
			var srw as int
			var srh as int
			IFDEF "target_java" {
				lang "java" {{{
					int msw = android.view.View.MeasureSpec.UNSPECIFIED;
					int msh = android.view.View.MeasureSpec.UNSPECIFIED;
					if(widthConstraint >= 0) {
						msw = android.view.View.MeasureSpec.makeMeasureSpec(widthConstraint, android.view.View.MeasureSpec.EXACTLY);
					}
					widget.measure(msw, msh);
					srw = widget.getMeasuredWidth();
					srh = widget.getMeasuredHeight();
				}}}
			}
			ELSE IFDEF "target_kotlin" {
				lang "kotlin" {{{
					var msw = android.view.View.MeasureSpec.UNSPECIFIED
					var msh = android.view.View.MeasureSpec.UNSPECIFIED
					if(widthConstraint >= 0) {
						msw = android.view.View.MeasureSpec.makeMeasureSpec(widthConstraint, android.view.View.MeasureSpec.EXACTLY)
					}
					widget!!.measure(msw, msh)
					srw = widget!!.getMeasuredWidth()
					srh = widget!!.getMeasuredHeight()
				}}}
			}
			if widthConstraint >= 0 && srw < widthConstraint:
				srw = widthConstraint
			setLayoutSize(widget, srw, srh)
		}
		ELSE IFDEF "target_html" {
			var ww = 0
			var hh = 0
			if widthConstraint >= 0 {
				var wws #used = String.forInteger(widthConstraint) .. "px"
				lang "js" {{{
					widget.element.style["white-space"] = "normal";
					widget.element.style["width"] = wws;
					hh = widget.element.offsetHeight;
				}}}
				widget.cachedWidth = widthConstraint
				ww = widthConstraint
			}
			else {
				lang "js" {{{
					widget.element.style["white-space"] = "nowrap";
					widget.element.style["width"] = "auto";
					ww = widget.element.getBoundingClientRect().width;
					hh = widget.element.offsetHeight;
				}}}
				ww ++
			}
			setLayoutSize(widget, ww, hh)
			if widget is ResizeAwareWidget:
				(widget as! ResizeAwareWidget).onWidgetResized()
		}
		ELSE IFDEF "target_uwp" {
			var srw as int
			var srh as int
			lang "cs" {{{
				Windows.Foundation.Size available;
				available.Height = float.PositiveInfinity;
				if(widthConstraint >= 0) {
					available.Width = (float)widthConstraint;
				}
				else {
					available.Width = float.PositiveInfinity;
				}
				widget.Measure(available);
				srw = (int)System.Math.Ceiling(widget.DesiredSize.Width);
				srh = (int)System.Math.Ceiling(widget.DesiredSize.Height);
				widget.InvalidateMeasure();
			}}}
			if widthConstraint >= 0 && srw < widthConstraint:
				srw = widthConstraint
			setLayoutSize(widget, srw, srh)
		}
		ELSE {
			ERROR "Not implemented."
		}
	}
}

IFDEF "target_ios"
{
	class WidgetClickForwarder
	{
		prop handler as function
		prop widget as Widget

		IFDEF "target_objc" {
			func execute
			{
				lang "objc" {{{
					[[widget.window.subviews objectAtIndex:0] endEditing:YES];
				}}}
				if handler:
					handler()
			}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				@objc func execute() {
					widget.window!.subviews[0].endEditing(true)
					handler!()
				}
			}}}
		}
	}

	class WidgetTouchForwarder
	{
		prop onStartHandler as function<void, double, double>
		prop onTouchHandler as function<void, double, double>
		prop onEndHandler as function<void, double, double>
		prop widget as Widget

		IFDEF "target_objc" {
			func execute(gesture as !"UIGestureRecognizer")
			{
				lang "objc" {{{
					CGPoint tappedPoint = [gesture locationInView:widget];
					CGFloat x = tappedPoint.x;
					CGFloat y = tappedPoint.y;
					if (gesture.state == UIGestureRecognizerStateBegan && onStartHandler) {
						onStartHandler((double)x, (double)y);
					}
					else if (gesture.state == UIGestureRecognizerStateChanged && onTouchHandler) {
						onTouchHandler((double)x, (double)y);
					}
					else if (gesture.state == UIGestureRecognizerStateEnded && onEndHandler) {
						onEndHandler((double)x, (double)y);
					}
				}}}
			}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				@objc func execute(_ gesture: UIGestureRecognizer) {
					let tappedPoint : CGPoint = gesture.location(in: widget)
					let x : CGFloat = tappedPoint.x
					let y : CGFloat = tappedPoint.y
					if (gesture.state == UIGestureRecognizer.State.began && (onStartHandler != nil)) {
						onStartHandler!(Double(x), Double(y))
					}
					else if (gesture.state == UIGestureRecognizer.State.changed && (onTouchHandler != nil)) {
						onTouchHandler!(Double(x), Double(y))
					}
					else if (gesture.state == UIGestureRecognizer.State.ended && (onEndHandler != nil)) {
						onEndHandler!(Double(x), Double(y))
					}
				}
			}}}
		}
	}

	class MyGestureRecognizer extends !"UIGestureRecognizer"
	{
		IFDEF "target_objc" {

			lang "objc" {{{
				- (id) initWithTarget:(id)target action:(SEL)action
				{
					if ([super initWithTarget:target action:action] == nil) {
						return(nil);
					}
					return(self);
				}
			}}}

			func touchesBegan(touches as !"NSSet *", withEvent as !"UIEvent *")
			{
				lang "objc" {{{
					[super touchesBegan:touches withEvent:withEvent];
					if (self.state != UIGestureRecognizerStatePossible && touches.count > 1) {
						return;
					}
					self.state = UIGestureRecognizerStateBegan;
				}}}
			}

			func touchesEnded(touches as !"NSSet *", withEvent as !"UIEvent *")
			{
				lang "objc" {{{
					[super touchesEnded:touches withEvent:withEvent];
					self.state = UIGestureRecognizerStateEnded;
				}}}
			}

			func touchesMoved(touches as !"NSSet *", withEvent as !"UIEvent *")
			{
				lang "objc" {{{
					[super touchesMoved:touches withEvent:withEvent];
					if (self.state == UIGestureRecognizerStateFailed || self.state == UIGestureRecognizerStateRecognized) {
						return;
					}
					self.state = UIGestureRecognizerStateChanged;
				}}}
			}

			func touchesCancelled(touches as !"NSSet *", withEvent as !"UIEvent *")
			{
				lang "objc" {{{
					[super touchesCancelled:touches withEvent:withEvent];
					self.state = UIGestureRecognizerStateCancelled;
				}}}
			}

			func reset
			{
				lang "objc" {{{
					[super reset];
				}}}
			}
		}
		ELSE IFDEF "target_swift" {
			ctor(target pname target as !"Any", action pname action as !"Selector") #override
			{
				lang "swift" {{{
					super.init(target: target, action: action)
				}}}
			}

			lang "swift" {{{
				override public func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent) {
					super.touchesBegan(touches, with: event)
					if (self.state != UIGestureRecognizer.State.possible && touches.count > 1) {
						return
					}
					self.state = UIGestureRecognizer.State.began
				}

				override public func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent) {
					super.touchesEnded(touches, with:event)
					self.state = UIGestureRecognizer.State.ended
				}

				override public func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {
					super.touchesMoved(touches, with:event!)
					if (self.state == UIGestureRecognizer.State.failed || self.state == UIGestureRecognizer.State.recognized) {
						return
					}
					self.state = UIGestureRecognizer.State.changed
				}

				override public func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?) {
					super.touchesCancelled(touches, with: event!)
					self.state = UIGestureRecognizer.State.cancelled
				}
			}}}
		}
	}

	class WidgetLongPressForwarder
	{
		prop handler as function
		prop widget as Widget

		IFDEF "target_objc" {
			func execute(gesture as !"UIGestureRecognizer")
			{
				lang "objc" {{{
					if (gesture.state == UIGestureRecognizerStateBegan) {
						handler();
					}
				}}}
			}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				@objc func execute(_ gesture : UIGestureRecognizer) {
					if (gesture.state == UIGestureRecognizer.State.began) {
						handler!()
					}
				}
			}}}
		}
	}
}

IFDEF "target_uwp" {
	var existingWidgetClickHandler static as !"Windows.UI.Xaml.Input.PointerEventHandler"
	var existingWidgetDoubleClickHandler static as !"Windows.UI.Xaml.Input.DoubleTappedEventHandler"
	var singleClick static #used = false
}

func togglePointerEventHandling(widget as this, value as bool) static
{
	var cw = assert widget as ContainerWidget
	cw.togglePointerEventHandling(value)
}

func setWidgetClickHandler(widget as this, handler as function) static
{
	if handler {
		togglePointerEventHandling(widget, true)
	}
	else {
		togglePointerEventHandling(widget, false)
	}
	IFDEF "target_ios" {
		var forwarder = new WidgetClickForwarder()
		forwarder.setWidget(widget)
		forwarder.setHandler(handler)
		IFDEF "target_objc" {
			lang "objc" {{{
				objc_setAssociatedObject(widget, "_gestureHandler", forwarder, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
				[widget setUserInteractionEnabled:YES];
				[widget addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:forwarder action:@selector(execute)]];
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				objc_setAssociatedObject(widget, "_gestureHandler", forwarder, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)
				widget.isUserInteractionEnabled = true
				widget.addGestureRecognizer(UITapGestureRecognizer(target: forwarder, action: #selector(forwarder.execute)))
			}}}
		}
	}
	ELSE IFDEF "target_android" {
		var hf final #used = handler
		IFDEF "target_java" {
			lang "java" {{{
				if(handler == null) {
					widget.setOnClickListener(null);
				}
				else {
					widget.setOnClickListener(new android.view.View.OnClickListener() {
						public void onClick(android.view.View view) {
							hf.execute();
						}
					});
				}
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				if(handler == null) {
					widget!!.setOnClickListener(null)
				}
				else {
					widget!!.setOnClickListener({ view ->
						hf!!.invoke()
					})
				}
			}}}
		}
	}
	ELSE IFDEF "target_html" {
		lang "js" {{{
			widget.element.onclick = handler;
		}}}
		if widget is ContainerWidget == false:
			HTMLDOM.setStyle(widget.element, "pointer-events", "auto")
		HTMLDOM.setStyle(widget.element, "cursor", "pointer")
	}
	ELSE IFDEF "target_uwp" {
		if existingWidgetClickHandler {
			lang "cs" {{{
				widget.PointerReleased -= existingWidgetClickHandler;
			}}}
			existingWidgetClickHandler = null
		}
		if handler {
			lang "cs" {{{
				existingWidgetClickHandler = async (object sender, Windows.UI.Xaml.Input.PointerRoutedEventArgs e) => {
					singleClick = true;
					await System.Threading.Tasks.Task.Delay(200);
					if(singleClick) {
						handler();
					}
				};
				widget.PointerReleased += existingWidgetClickHandler;
			}}}
		}
	}
	ELSE {
		ERROR "Not implemented"
	}
}

func setWidgetDoubleClickHandler(widget as this, handler as function) static
{
	if handler {
		togglePointerEventHandling(widget, true)
	}
	else {
		togglePointerEventHandling(widget, false)
	}
	IFDEF "target_uwp" {
		if existingWidgetDoubleClickHandler {
			lang "cs" {{{
				widget.DoubleTapped -= existingWidgetDoubleClickHandler;
			}}}
			existingWidgetDoubleClickHandler = null
		}
		if handler {
			lang "cs" {{{
				existingWidgetDoubleClickHandler = (object sender, Windows.UI.Xaml.Input.DoubleTappedRoutedEventArgs e) => {
					singleClick = false;
					handler();
				};
				widget.DoubleTapped += existingWidgetDoubleClickHandler;
			}}}
		}
	}
	ELSE IFDEF "target_html" {
		assert handler
		HTMLDOM.addEventListener(widget.element, "dblclick", handler)
	}
	ELSE {
		ERROR "Not implemented"
	}
}

func setWidgetLongClickHandler(widget as this, handler as function) static
{
	if handler {
		togglePointerEventHandling(widget, true)
	}
	else {
		togglePointerEventHandling(widget, false)
	}
	IFDEF "target_ios" {
		var forwarder = new WidgetLongPressForwarder()
		forwarder.setWidget(widget)
		forwarder.setHandler(handler)
		IFDEF "target_objc" {
			lang "objc" {{{
				objc_setAssociatedObject(widget, "_gestureHandler", forwarder, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
				[widget setUserInteractionEnabled:YES];
				[widget addGestureRecognizer:[[UILongPressGestureRecognizer alloc] initWithTarget:forwarder action:@selector(execute:)]];
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				objc_setAssociatedObject(widget, "_gestureHandler", forwarder, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)
				widget.isUserInteractionEnabled = true
				widget.addGestureRecognizer(UILongPressGestureRecognizer(target: forwarder, action: #selector(forwarder.execute(_ :))))
			}}}
		}
	}
	ELSE IFDEF "target_android" {
		var hf final #used = handler
		IFDEF "target_java" {
			lang "java" {{{
				if(handler == null) {
					widget.setOnLongClickListener(null);
				}
				else {
					widget.setOnLongClickListener(new android.view.View.OnLongClickListener() {
						public boolean onLongClick(android.view.View view) {
							hf.execute();
							return true;
						}
					});
				}
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				if(handler == null) {
					widget!!.setOnLongClickListener(null)
				}
				else {
					widget!!.setOnLongClickListener(object : android.view.View.OnLongClickListener {
						override fun onLongClick(view : android.view.View?) : Boolean {
							hf!!.invoke()
							return true
						}
					})
				}
			}}}
		}
	}
	ELSE IFDEF "target_html" {
		lang "js" {{{
			var timer = null;
			widget.element.onmousedown = function(){
				timer = setTimeout( handler, 500 );
			};
			widget.element.onmouseup = function(){
				clearTimeout( timer );
			};
		}}}
		HTMLDOM.setStyle(widget.element, "cursor", "pointer")
	}
	ELSE {
		ERROR "Not implemented"
	}
}

func setWidgetPointerHandlers(widget as this, onStartHandler as function<void, double, double> = null, onTouchHandler as function<void, double, double> = null, onEndHandler as function<void, double, double> = null) static
{
	if onStartHandler == null && onTouchHandler == null && onEndHandler == null {
		togglePointerEventHandling(widget, false)
	}
	else {
		togglePointerEventHandling(widget, true)
	}
	IFDEF "target_android" {
		var othf final #used = onTouchHandler
		var oshf final #used = onStartHandler
		var oehf final #used = onEndHandler
		IFDEF "target_java" {
			lang "java" {{{
				if(onStartHandler == null && onTouchHandler == null && onEndHandler == null) {
					widget.setOnTouchListener(null);
				}
				else {
					widget.setOnTouchListener(new android.view.View.OnTouchListener() {
						public boolean onTouch(android.view.View view, android.view.MotionEvent event) {
							int action = event.getAction();
							if(action == android.view.MotionEvent.ACTION_DOWN && oshf != null) {
								oshf.execute((double)event.getX(), (double)event.getY());
							}
							else if(action == android.view.MotionEvent.ACTION_MOVE && othf != null) {
								othf.execute((double)event.getX(), (double)event.getY());
							}
							else if((action == android.view.MotionEvent.ACTION_UP || action == android.view.MotionEvent.ACTION_CANCEL) && oehf != null) {
								oehf.execute((double)event.getX(), (double)event.getY());
							}
							return true;
						}
					});
				}
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				if(onStartHandler == null && onTouchHandler == null && onEndHandler == null) {
					widget!!.setOnTouchListener(null)
				}
				else {
					widget!!.setOnTouchListener(object : android.view.View.OnTouchListener {
						override fun onTouch(view : android.view.View?, event : android.view.MotionEvent?) : Boolean {
							var action = event!!.getAction()
							if(action == android.view.MotionEvent.ACTION_DOWN && oshf != null) {
								oshf!!.invoke(event!!.getX().toDouble(), event!!.getY().toDouble())
							}
							else if(action == android.view.MotionEvent.ACTION_MOVE && othf != null) {
								othf!!.invoke(event!!.getX().toDouble(), event!!.getY().toDouble())
							}
							else if((action == android.view.MotionEvent.ACTION_UP || action == android.view.MotionEvent.ACTION_CANCEL) && oehf != null) {
								oehf!!.invoke(event!!.getX().toDouble(), event!!.getY().toDouble())
							}
							return true
						}
					})
				}
			}}}
		}
	}
	ELSE IFDEF "target_html" {
		lang "js" {{{
			var mousedown = false;
			var getCoordinates = function(evt) {
				var rect = widget.element.getBoundingClientRect();
				var x = evt.clientX - rect.left;
				var y = evt.clientY - rect.top;
				return { x : x, y : y};
			};
			if(onTouchHandler != null) {
				var othf = function(evt) {
					if(mousedown) {
						CaveHTMLDOM.setStyle(widget.element, "cursor", "move");
						onTouchHandler(getCoordinates(evt).x, getCoordinates(evt).y);
					}
				};
				widget.element.onmousemove = othf;
			}
			if(onStartHandler != null) {
				var oshf = function(evt) {
					mousedown = true;
					onStartHandler(getCoordinates(evt).x, getCoordinates(evt).y);
				};
				widget.element.onmousedown = oshf;
			}
			if(onEndHandler != null) {
				var oehf = function(evt) {
					if(mousedown) {
						CaveHTMLDOM.setStyle(widget.element, "cursor", "auto");
						onEndHandler(getCoordinates(evt).x, getCoordinates(evt).y);
						mousedown = false;
					}
				};
				widget.element.onmouseup = oehf;
			}
		}}}
	}
	ELSE IFDEF "target_ios" {
		var forwarder = new WidgetTouchForwarder()
		forwarder.setWidget(widget)
		forwarder.setOnStartHandler(onStartHandler)
		forwarder.setOnTouchHandler(onTouchHandler)
		forwarder.setOnEndHandler(onEndHandler)
		IFDEF "target_objc" {
			lang "objc" {{{
				objc_setAssociatedObject(widget, "_gestureHandler", forwarder, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
				[widget setUserInteractionEnabled:YES];
				[widget addGestureRecognizer:[[CaveUIWidgetMyGestureRecognizer alloc] initWithTarget:forwarder action:@selector(execute:)]];
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				objc_setAssociatedObject(widget, "_gestureHandler", forwarder, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)
				widget.isUserInteractionEnabled = true
				widget.addGestureRecognizer(CaveUiWidgetMyGestureRecognizer(target: forwarder, action: #selector(forwarder.execute(_ :))))
			}}}
		}
	}
	ELSE IFDEF "target_uwp" {
		if onStartHandler {
			ERROR "setWidgetPointerHandlers/onStartHandler: Not implemented"
		}
		if onTouchHandler {
			ERROR "setWidgetPointerHandlers/onStartHandler: Not implemented"
		}
		if onEndHandler {
			setWidgetClickHandler(widget, func {
				onEndHandler(0, 0)
			})
		}
	}
	ELSE {
		ERROR "Not implemented"
	}
}

func removeChildrenOf(widget as this) static
{
	assert widget
	var children = getChildren(widget)
	IFDEF "target_html" {
		lang "js" {{{
			widget.element.textContent = "";
		}}}
		var screen = ScreenForWidget.findScreenForWidget(widget)
		var pp = widget as ContainerWidget
		foreach child in children {
			if screen:
				notifyOnRemovedFromScreen(child, screen)
			onWidgetRemovedFromParent(child)
		}
		if pp:
			pp.onChildWidgetsRemoved(children)
	}
	ELSE {
		foreach child in children:
			removeFromParent(child)
	}
}

func onLayoutChanged(widget as this) static
{
	assert widget
	var wwl = widget as WidgetWithLayout
	if wwl && wwl.hasWidgetLayoutChanged() {
		// already processed, no need to redo..
		return
	}
	if isRootWidget(widget) {
		(widget as! ContainerWidget).scheduleLayout()
	}
	else {
		var pp = getParent(widget) as this
		if pp {
			onLayoutChanged(pp)
		}
		else {
			var root = findRootWidget(widget)
			if root:
				root.scheduleLayout()
		}
	}
	if wwl:
		wwl.setWidgetLayoutChanged()
}

func setAlpha(widget as this, alpha as double) static
{
	assert widget
	IFDEF "target_android" {
		IFDEF "target_java" {
			lang "java" {{{
				widget.setAlpha((float)alpha);
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				widget!!.setAlpha(alpha.toFloat())
			}}}
		}
	}
	ELSE IFDEF "target_html5" {
		HTMLDOM.setStyle(widget.element, "opacity", String.forDouble(alpha))
	}
	ELSE IFDEF "target_ios" {
		IFDEF "target_objc" {
			lang "objc" {{{
				[widget setAlpha:(CGFloat)alpha];
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				widget.alpha = CGFloat(alpha)
			}}}
		}
	}
	ELSE {
		ERROR "Not implemented"
	}
}

func setRotation(widget as this, degrees as double) static
{
	assert widget
	IFDEF "target_android" {
		IFDEF "target_java" {
			lang "java" {{{
				widget.setRotation((float)degrees);
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlins" {{{
				widget!!.setRotation(degrees.toFloat())
			}}}
		}
	}
	ELSE IFDEF "target_ios" {
		IFDEF "target_objc" {
			degrees = -degrees
			lang "objc" {{{
				[widget setTransform:CGAffineTransformMakeRotation((CGFloat)degrees)];
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				widget.transform = CGAffineTransform(rotationAngle: CGFloat(degrees))
			}}}
		}
	}
	ELSE IFDEF "target_html" {
		var element = widget.element
		var ang = degrees * 180.0 / Math.M_PI
		var str = "rotate(" .. String.forInteger(ang as int) .. "deg)"
		HTMLDOM.setStyle(element, "transform", str)
		HTMLDOM.setStyle(element, "webkitTransform", str)
		HTMLDOM.setStyle(element, "msTransform", str)
		HTMLDOM.setStyle(element, "oTransform", str)
		HTMLDOM.setStyle(element, "mozTransform", str)
	}
	ELSE {
		ERROR "Not implemented"
	}
}

func setEnabled(widget as this, enabled as bool) static
{
	assert widget
	IFDEF "target_android" {
		IFDEF "target_java" {
			lang "java" {{{
				widget.setEnabled(enabled);
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				widget!!.setEnabled(enabled)
			}}}
		}
	}
	ELSE IFDEF "target_html5" {
		var elem #used = widget.element
		lang "js" {{{
			elem.disabled = !enabled;
		}}}
	}
	ELSE IFDEF "target_ios" {
		IFDEF "target_objc" {
			lang "objc" {{{
				if(enabled) {
					widget.userInteractionEnabled = YES;
				}
				else {
					widget.userInteractionEnabled = NO;
				}
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				if(enabled) {
					widget.isUserInteractionEnabled = true
				}
				else {
					widget.isUserInteractionEnabled = false
				}
			}}}
		}
	}
	ELSE {
		ERROR "Not implemented"
	}
}

func setTabIndex(widget as this, index as int) static
{
	assert widget
	IFDEF "target_html" {
		HTMLDOM.setAttribute(widget.element, "tabIndex", String.forInteger(index))
	}
	ELSE {
		ERROR "Not Implemented"
	}
}

func setVisible(widget as this, visible as bool) static
{
	assert widget
	IFDEF "target_html" {
		if visible {
			HTMLDOM.setStyle(widget.element, "visibility", "inherit")
		}
		else {
			HTMLDOM.setStyle(widget.element, "visibility", "hidden")
		}
	}
	ELSE IFDEF "target_ios" {
		var hidden #used = not visible
		IFDEF "target_objc" {
			lang "objc" {{{
				[widget setHidden:hidden];
			}}}
		}
		ELSE IFDEF "target_swift" {
			lang "swift" {{{
				widget.isHidden = hidden
			}}}
		}
	}
	ELSE IFDEF "target_android" {
		IFDEF "target_java" {
			lang "java" {{{
				if(visible) {
					widget.setVisibility(android.view.View.VISIBLE);
				}
				else {
					widget.setVisibility(android.view.View.INVISIBLE);
				}
			}}}
		}
		ELSE IFDEF "target_kotlin" {
			lang "kotlin" {{{
				if(visible) {
					widget!!.setVisibility(android.view.View.VISIBLE)
				}
				else {
					widget!!.setVisibility(android.view.View.INVISIBLE)
				}
			}}}
		}
	}
	ELSE {
		ERROR "Not implemented"
	}
}

func getVisible(widget as this) static as bool
{
	assert widget
	IFDEF "target_html" {
		var visible = false
		var visibility = HTMLDOM.getStyle(widget.element, "visibility")
		if String.equals(visibility, "visible") || String.equals(visibility, "inherit"):
			visible = true
		return visible
	}
	ELSE IFDEF "target_ios" {
		IFDEF "target_objc" {
			return lang "objc" bool {{{ !widget.hidden }}}
		}
		ELSE IFDEF "target_swift" {
			return lang "swift" bool {{{ widget.isHidden }}}
		}
	}
	ELSE IFDEF "target_android" {
		var v as bool
		IFDEF "target_java" {
			v = lang "java" bool {{{ widget.getVisibility() == android.view.View.VISIBLE }}}
		}
		ELSE IFDEF "target_kotlin" {
			v = lang "kotlin" bool {{{ widget!!.getVisibility() == android.view.View.VISIBLE }}}
		}
		return v
	}
	ELSE {
		ERROR "Not implemented"
		return false
	}
}

func setWidgetId(widget as this, idValue as object) static
{
	assert widget
	if widget is IdAwareWidget {
		(widget as IdAwareWidget).setWidgetId(idValue)
	}
	else {
		IFDEF "target_html" {
			HTMLDOM.setAttribute(widget.element, "id", String.asString(idValue))
		}
		IFDEF "target_android" {
			IFDEF "target_java" {
				lang "java" {{{
					if(idValue instanceof java.lang.Integer) {
						widget.setId(((java.lang.Integer)idValue).intValue());
					}
				}}}
			}
		}
		IFDEF "target_ios" {
			IFDEF "target_objc" {
				lang "objc" {{{
					[widget setAccessibilityIdentifier:idValue];
				}}}
			}
			ELSE IFDEF "target_swift" {
				lang "swift" {{{
					widget.accessibilityIdentifier = idValue as? String
				}}}
			}
		}
		ELSE {
			ERROR "Not yet implemented"
		}
	}
}

IFDEF "target_html"
{
	func addToDomElement(widget as ContainerWidget, parentElement as object) static
	{
		assert widget
		assert parentElement
		HTMLDOM.setStyle(parentElement, "display", "table")
		HTMLDOM.setStyle(parentElement, "overflow", "hidden")
		if parentElement == HTMLDOM.getDocumentBody() {
			HTMLDOM.setStyle(parentElement, "width", "100%")
			HTMLDOM.setStyle(parentElement, "height", "100%")
			var html = HTMLDOM.getElementsByTagName(HTMLDOM.getDocument(), "html")[0]
			HTMLDOM.setStyle(html, "width", "100%")
			HTMLDOM.setStyle(html, "height", "100%")
		}
		HTMLDOM.setStyle(widget.element, "display", "table-cell")
		HTMLDOM.setStyle(widget.element, "position", "relative")
		HTMLDOM.setStyle(widget.element, "width", "100%")
		HTMLDOM.setStyle(widget.element, "height", "100%")
		HTMLDOM.appendChild(parentElement, widget.element)
		widget.onWidgetAddingToParent()
		widget.onWidgetAddedToParent()
		widget.scheduleLayout()
	}
}
