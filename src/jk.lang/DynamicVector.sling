
/*
 * This file is part of Eqela Jkop
 * Copyright (c) 2016-2022 J42 Pte Ltd
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class is Duplicateable is Iterateable<dynamic> is VectorObject<dynamic> is ObjectWithSize:

func asDynamicVector(value as dynamic) static as this
{
	assert value
	if value is this:
		return value as! this
	if value is array:
		return forArray(value as! array)
	if value is vector:
		return forVector(value as! vector)
	return null
}

func forStringVector(vector as vector<string>) static as this
{
	var v = new this()
	foreach item in vector:
		v.appendString(item)
	return v
}

func forVector(vector as vector) static as this
{
	var v = new this()
	foreach item in vector:
		v.appendDynamic(item)
	return v
}

func forArray(array as array) static as this
{
	var v = new this()
	foreach item in array:
		v.appendDynamic(item)
	return v
}

var vector as vector

ctor:
	vector = new vector

func toVector as vector:
	return vector

func toVectorOfStrings as vector<string>
{
	var v = new vector<string>
	foreach o in vector {
		var s = String.asString(o)
		if s:
			v += s
	}
	return v
}

func toVectorOfDynamicMaps as vector<DynamicMap>
{
	var v = new vector<DynamicMap>
	foreach o as DynamicMap in vector:
		v += o
	return v
}

func duplicate as object
{
	var v = new this()
	var it = iterate()
	while it {
		var o = it.next()
		if o == null:
			break
		v.appendDynamic(o)
	}
	return v
}

func mergeDynamicVector(dynamicVector as this) as this
{
	if not dynamicVector || dynamicVector.getSize() < 1:
		return this
	return mergeVector(dynamicVector.toVector())
}

func mergeVector(vector as vector) as this
{
	foreach item in vector:
		appendDynamic(item)
	return this
}

func appendDynamic(value as dynamic) as this
{
	vector += value
	return this
}

func appendObject(value as object) as this
{
	vector += value
	return this
}

func appendString(value as string) as this
{
	vector += value
	return this
}

func appendInteger(value as int) as this
{
	vector += Integer.asObject(value)
	return this
}

func appendLong(value as long) as this
{
	vector += LongInteger.asObject(value)
	return this
}

func appendBoolean(value as bool) as this
{
	vector += Boolean.asObject(value)
	return this
}

func appendDouble(value as double) as this
{
	vector += Double.asObject(value)
	return this
}

func setDynamic(index as int, value as dynamic) as this
{
	Vector.set(vector, index, value)
	return this
}

func setObject(index as int, value as object) as this
{
	Vector.set(vector, index, value)
	return this
}

func setInteger(index as int, value as int) as this
{
	Vector.set(vector, index, Integer.asObject(value))
	return this
}

func setLong(index as int, value as long) as this
{
	Vector.set(vector, index, LongInteger.asObject(value))
	return this
}

func setBoolean(index as int, value as bool) as this
{
	Vector.set(vector, index, Boolean.asObject(value))
	return this
}

func setDouble(index as int, value as double) as this
{
	Vector.set(vector, index, Double.asObject(value))
	return this
}

func get(index as int) as dynamic:
	return Vector.getAt(vector, index)

func getString(index as int, defval as string = null) as string
{
	var v = String.asString(get(index))
	if v == null:
		return defval
	return v
}

func getInteger(index as int, defval as int = 0) as int
{
	var vv = get(index)
	if vv == null:
		return defval
	return Integer.asInteger(vv)
}

func getLongInteger(index as int, defval as long = 0) as long
{
	var vv = get(index)
	if vv == null:
		return defval
	return LongInteger.asLong(vv)
}

func getBoolean(index as int, defval as bool = false) as bool
{
	var vv = get(index)
	if vv == null:
		return defval
	return Boolean.asBoolean(vv)
}

func getDouble(index as int, defval as double = 0.0) as double
{
	var vv = get(index)
	if vv == null:
		return defval
	return Double.asDouble(vv)
}

func getMap(index as int) as DynamicMap:
	return get(index) as DynamicMap

func getVector(index as int) as this:
	return get(index) as this

func iterate as Iterator<dynamic>:
	return Vector.iterate(vector)

func iterateReverse as Iterator<dynamic>:
	return Vector.iterateReverse(vector)

func remove(index as int):
	Vector.remove(vector, index)

func removeValue(value as dynamic):
	Vector.removeValue(vector, value)

func clear:
	Vector.clear(vector)

func contains(value as dynamic) as bool:
	return Vector.contains(vector, value)

func getSize as int:
	return Vector.getSize(vector)

func setCapacity(capacity as int):
	Vector.setCapacity(vector, capacity)

func sort
{
	Vector.sort(vector, func(a as dynamic, b as dynamic) as int {
		return String.compare(String.asString(a), String.asString(b))
	})
}

func sortWithComparer(comparer as function<int,dynamic,dynamic>)
{
	if comparer == null {
		sort()
		return
	}
	Vector.sort(vector, comparer)
}

func sortReverse
{
	Vector.sortReverse(vector, func(a as dynamic, b as dynamic) as int {
		return String.compare(String.asString(a), String.asString(b))
	})
}

func sortReverseWithComparer(comparer as function<int,dynamic,dynamic>)
{
	if comparer == null {
		sortReverse()
		return
	}
	Vector.sortReverse(vector, comparer)
}
