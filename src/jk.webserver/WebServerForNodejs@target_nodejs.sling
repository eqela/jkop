
/*
 * This file is part of Eqela Jkop
 * Copyright (c) 2016-2023 J42 Pte Ltd
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import jk.log
import jk.nodejs

class is WebServer:

class WebServerRequestForNodejs public is WebServerRequest
{
	prop req as dynamic
	prop res as dynamic

	ctor(req as dynamic, res as dynamic)
	{
		this.req = req
		this.res = res
	}

	func getMethod override as string:
		return req.method as! string

	func getPath(withQuery as bool = true) override as string
	{
		if withQuery:
			return req.url as! string
		return Vector.get(String.split(req.url as! string, '?'), 0)
	}

	func getHeaders override as vector<KeyValuePair<string,string>>
	{
		var v = new vector<KeyValuePair<string,string>>
		var hdrs = req.headers
		lang "js" {{{
			for(var key in hdrs) {
				var val = hdrs[key]
				}}}
				var kvp = new KeyValuePair<string,string>()
				kvp.key = lang "js" string {{{ key }}}
				kvp.value = lang "js" string {{{ val }}}
				v += kvp
				lang "js" {{{
			}
		}}}
		return v
	}

	func getHeader(key as string) override as string
	{
		var hdrs = req.headers
		return lang "js" string {{{ hdrs[key.toLowerCase()] }}}
	}

	func setHeader(key as string, value as string) override
	{
		var hdrs = req.headers
		lang "js" {{{
			hdrs[key.toLowerCase()] = value
		}}}
	}

	func removeHeader(key as string) override
	{
		var hdrs = req.headers
		lang "js" {{{
			delete hdrs[key.toLowerCase()]
		}}}
	}

	func readBodyChunk override async as promise<buffer>
	{
		return new promise<buffer> {
			var ondata as function<void,buffer>
			var onend as function
			ondata = func(data as buffer) {
				req.removeListener("data", ondata)
				req.removeListener("end", onend)
				resolve data
			}
			onend = func {
				req.removeListener("data", ondata)
				req.removeListener("end", onend)
				resolve null
			}
			req.on("data", ondata)
			req.on("end", onend)
		}
	}

	func readBodyAsBuffer override async as buffer
	{
		var bb = new BufferBuilder()
		loop {
			var chunk = await readBodyChunk()
			if not chunk:
				break
			bb.appendBuffer(chunk)
		}
		return bb.toBuffer()
	}

	func readBodyAsString override async as string
	{
		var buffer = await readBodyAsBuffer()
		assert buffer
		return String.forUTF8Buffer(buffer)
	}

	func setResponseHeader(key as string, value as string) override:
		res.setHeader(key, value)

	func setResponseHeaderList(headers as KeyValueList<string,string>) override
	{
		assert headers
		var it = headers.iterate()
		while it {
			var pair = it.next()
			if not pair:
				break
			setResponseHeader(pair.key, pair.value)
		}
	}

	func setResponseHeaders(headers as dynamic) override
	{
		foreach name in DynamicObject.getPropertyNames(headers):
			setResponseHeader(name, String.asString(DynamicObject.getPropertyValue(headers, name)))
	}

	func setResponseStatus(code as int) override:
		res.statusCode = code

	func writeResponseData(data as buffer) override async as promise
	{
		return new promise {
			res.write(data, null, func {
				resolve
			})
		}
	}

	func endResponse override async as promise
	{
		return new promise {
			res.end(null, null, func {
				resolve
			})
		}
	}
}

class WebSocketServerRequestForNodejs public is WebServerRequestForNodejs
{
	prop socket as dynamic
	prop status as string
	prop headerList as vector<string>
	prop data as buffer

	ctor(req as dynamic, socket as dynamic)
	{
		base(req, null as! dynamic)
		this.socket = socket
	}

	func setResponseStatus(code as int) override:
		status = String.forInteger(code)

	func setResponseHeader(key as string, value as string) override
	{
		if not headerList:
			headerList = new vector<string>
		headerList += key .. ": " .. value
	}

	func writeResponseData(data as buffer) override async as promise:
		this.data = Buffer.append(this.data, data)
	
	func getStatusDescription(status as string) as string
	{
		assert status
		var http = NodeModule.require("http")
		var v = String.asString(http.STATUS_CODES[status])
		if String.isEmpty(v):
			v = "Http" .. status
		return v
	}

	func endResponse override async as promise
	{
		assert socket
		var sb = new StringBuilder()
		sb.appendString("HTTP/1.1 " .. status .. " " .. getStatusDescription(status) .. "\r\n")
		foreach header in headerList:
			sb.appendString(header .. "\r\n")
		sb.appendString("\r\n")
		var data = String.toUTF8Buffer(sb.toString())
		if this.data:
			data = Buffer.append(data, this.data)
		socket.end(data)
	}
}

func waitForServers(ctx as LoggingContext, servers as vector<WebServer>) async static
{
	var nservers = Vector.getSize(servers)
	if nservers < 1:
		Error.throw("noServersToWaitFor", servers)
	var promises = new vector<promise>
	foreach server in servers {
		var tserver = server as this
		if not tserver:
			Error.throw("unsupportedWebServer", server)
		var nserver = tserver.server
		if not nserver:
			Error.throw("nodeHttpServerMissing", tserver)
		promises += new promise<void> {
			nserver.on("close", func {
				resolve
			})
		}
	}
	if nservers == 1 {
		Log.info(ctx, "HTTP server ready and waiting.")
	}
	else {
		Log.info(ctx, String.forInteger(nservers) .. " HTTP servers ready and waiting.")
	}
	lang "js" {{{
		await Promise.all(promises)
	}}}
	if nservers == 1 {
		Log.info(ctx, "Node.JS HTTP server ended.")
	}
	else {
		Log.info(ctx, "Node.JS HTTP servers ended.")
	}
}

prop server as dynamic

func initialize override
{
	var http = NodeModule.require("http")
	server = http.createServer(func(req, res) async {
		await handleRequest(new WebServerRequestForNodejs(req, res))
	})
	server.on("upgrade", func(req, socket, head) async {
		await handleRequest(new WebSocketServerRequestForNodejs(req, socket))
	})
}

func start(port as int) async override
{
	await server.listen(port)
	Log.info(ctx, "Node.JS HTTP server listening on port " .. String.forInteger(port))
}

func execute(port as int) async override
{
	await start(port)
	await WebServer.waitForServers(ctx, new vector<WebServer> [ this ])
}

func stop async override:
	server.close()
