
/*
 * This file is part of Jkop
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class abstract:

import cape
import capex.data
import capex.net
import capex.crypto

prop server as WSServer
prop port = 9090
var ctx protected as LoggingContext
var connectionSize private as int
var random private as Random

func authenticateConnection(data as buffer, callback as function<void, string>) abstract
func getUser(userId as string, callback as function<void, ChatUser>) abstract
func getUserCount(callback as function<void, int>) abstract
func createAndSaveChannel(recipients as DynamicVector, creatorUserId as string, callback as function<void, ChatChannel>) abstract
func getChannel(channelId as string, callback as function<void, ChatChannel>) abstract
func createAcknowledgeCommand(userId as string, callback as function<void, ChatMessage>) abstract
func createMessage(data as buffer) abstract as ChatMessage
func saveMessage(message as ChatMessage, newChannelId as string, callback as function<void, Error>) abstract
func onUserOnline(user as ChatUser) abstract
func onUserOffline(user as ChatUser) abstract
func onNewCommandMessage(message as ChatMessage, connection as ChatConnectionHandler) abstract
func notifyUserForNewDataMessage(user as ChatUser, message as ChatMessage) abstract
func checkRecipientsAndSender(recipients as DynamicVector, creatorUserId as string, callback as function<void, bool>) abstract

ctor
{
	connectionSize = 0
	random = new Random()
}

func initialize virtual as bool:
	return true

func setCtx(ctx as LoggingContext):
	this.ctx = ctx

func getCtx as LoggingContext:
	return ctx

func initializeEngine(mgr as IOManager) as bool
{
	assert mgr:
		logError("No IOManager instance specified.")
	if not server {
		logWarning("No WebSocket server instance specified. Creating a new instance to listen on port: " .. String.forInteger(port) .. ".")
		server = new WSServer()
	}
	server.setPort(port)
	var engine final = this
	server.setCreateConnectionHandlerObject(func as WSServerConnectionHandler {
		return new ChatConnectionHandler().setEngine(engine).setLogContext(ctx)
	})
	assert server.initialize(mgr, ctx):
		logError("Failed to initialize WebSocket server.")
	assert initialize():
		logError("Failed to initialize chat engine.")
	logInfo("Successfully initialized chat engine.")
	return true
}

func generateId virtual as string:
	return MD5Encoder.encode(String.forInteger(SystemClock.asUTCSeconds()) .. String.forInteger(random.nextInt(9999999)) .. String.forInteger(random.nextInt(9999999)) .. String.forInteger(random.nextInt(9999999)))

func logError(message as string):
	Log.error(ctx, VALUE "__THIS__" .. ": " .. message)

func logWarning(message as string):
	Log.warning(ctx, VALUE "__THIS__" .. ": " .. message)

func logInfo(message as string):
	Log.info(ctx, VALUE "__THIS__" .. ": " .. message)

func logDebug(message as string):
	Log.debug(ctx, VALUE "__THIS__" .. ": " .. message)

func onDataReceived(data as buffer, connection as ChatConnectionHandler)
{
	assert connection
	assert data {
		connection.close()
	}
	var user = connection.getUser()
	if not user {
		onAuthenticateConnection(data, connection)
		return
	}
	onParseData(data, connection)
}

func onAuthenticateConnection(data as buffer, connection as ChatConnectionHandler) private
{
	authenticateConnection(data, func(userId as string) {
		assert String.isNotEmpty(userId) {
			logError("No userId returned by authenticateConnection() abstract method. Closing the connection instead.")
			connection.close()
		}
		getUser(userId, func(user as ChatUser) {
			assert user {
				logError("No ChatUser instance returned by getUser() abstract method. Closing the connection instead.")
				connection.close()
			}
			connection.setUser(user)
			loop {
				var connectionId = generateId()
				assert String.isNotEmpty(connectionId) {
					logError("No connectionId returned by generateId() abstract method. Closing the connection instead.")
					connection.close()
				}
				if not user.getConnection(connectionId) {
					connection.setConnectionId(connectionId)
					break
				}
			}
			user.addConnection(connection)
			connectionSize++
			getUserCount(func(count as int) {
				logDebug("New connection. Now: (" .. String.forInteger(connectionSize) .. "/" .. String.forInteger(count) .. ") connected")
			})
			createAcknowledgeCommand(userId, func(message as ChatMessage) {
				assert message {
					logError("Failed to create an acknowledge command message that the client is connected. Closing the connection instead.")
					connection.close()
				}
				assert message.getMessageType() == ChatMessage.COMMAND_TYPE {
					logError("Acknowledge command message not of type command. Closing the connection instead.")
					connection.close()
				}
				var r = connection.sendMessage(message)
				assert r > 0 {
					logError("Failed to send message. Closing the connection instead.")
					connection.close()
				}
				if user.getConnectionCount() == 1 {
					logDebug("User: '" .. user.getUserId() .. "' is now online")
					onUserOnline(user)
				}
			})
		})
	})
}

func onUserDisconnect(userId as string, connection as ChatConnectionHandler)
{
	getUser(userId, func(user as ChatUser) {
		assert user
		user.removeConnection(connection)
		connectionSize--
		getUserCount(func(count as int) {
			logDebug("Connection closed. Now: (" .. String.forInteger(connectionSize) .. "/" .. String.forInteger(count) .. ") connected")
		})
		if not user.isOnline() {
			logDebug("User: '" .. user.getUserId() .. "' is now offline with last active on: " .. String.forLongInteger(user.getLastActive()))
			onUserOffline(user)
		}
	})
}

func onParseData(data as buffer, connection as ChatConnectionHandler) private
{
	assert data {
		logError("No data buffer received. Closing the connection instead.")
		connection.close()
	}
	var message = assert createMessage(data) {
		logError("No ChatMessage instance returned by createMessage() abstract method. Closing the connection instead.")
		connection.close()
	}
	assert String.isEmpty(message.getMessageId()) {
		logError("ChatMessage instance returned by createMessage() abstract method should not be saved and have message id yet. Closing the connection instead.")
		connection.close()
	}
	switch message.getMessageType() {
		case ChatMessage.COMMAND_TYPE: {
			// We would want to have commands
			// like: SEEN, TYPING, ONLINE, OFFLINE,
			// UPLOADING_FILE, DONE_UPLOADING_FILE, etc.
			onNewCommandMessage(message, connection)
			break
		}
		case ChatMessage.DATA_TYPE: {
			onNewDataMessage(message, connection)
			break
		}
		default: {
			logError("ChatMessage message type is invalid. Closing the connection instead.")
			connection.close()
		}
	}
}

func onNewDataMessage(message as ChatMessage, connection as ChatConnectionHandler)
{
	assert message && message.getMessageType() == ChatMessage.DATA_TYPE:
		connection.close()
	var creatorUserId = message.getCreatorUserId()
	assert String.isNotEmpty(creatorUserId):
		connection.close()
	var channelId = message.getChannelId()
	if String.isEmpty(channelId) {
		createChannelAndGetId(message.getRecipients(), creatorUserId, func(newChannelId as string) {
			getChannel(newChannelId, func(channel as ChatChannel) {
				assert channel && String.equals(channel.getChannelId(), newChannelId):
					connection.close()
				onSaveMessage(message, channel, connection)
			})
		})
		return
	}
	getChannel(channelId, func(channel as ChatChannel) {
		assert channel && String.equals(channel.getChannelId(), channelId):
			connection.close()
		onSaveMessage(message, channel, connection)
	})
}

func onSaveMessage(message as ChatMessage, channel as ChatChannel, connection as ChatConnectionHandler) private
{
	saveMessage(message, channel.getChannelId(), func(error as Error) {
		assert not error:
			connection.close()
		assert String.isNotEmpty(message.getMessageId()):
			connection.close()
		assert String.equals(message.getChannelId(), channel.getChannelId()):
			connection.close()
		// FIXME:
		channel.onNewDataMessage(message)
	})
}

func createChannelAndGetId(recipients as DynamicVector, creatorUserId as string, callback as function<void, string>) private
{
	checkRecipientsAndSender(recipients, creatorUserId, func(valid as bool) {
		assert valid {
			logError("No creatorUserId or recipients or recipient count is less than two returned by checkRecipientsAndSender() method.")
			callback(null)
		}
		createAndSaveChannel(recipients, creatorUserId, func(channel as ChatChannel) {
			assert channel {
				logError("No ChatChannel instance returned by createChannel() abstract method.")
				callback(null)
			}
			var channelId = channel.getChannelId()
			assert String.isNotEmpty(channelId) {
				logError("Created ChatChannel instance returned by createChannel() abstract method doesn't have channelId.")
				callback(null)
			}
			logDebug("New channel '" .. channelId .. "' created")
			callback(channelId)
		})
	})
}

func broadcastMessage(message as ChatMessage)
{
	// FIXME:
	assert message
	var recipients = message.getRecipients()
	var creatorUserId = message.getCreatorUserId()
	checkRecipientsAndSender(recipients, creatorUserId, func(valid as bool) {
		assert valid:
			logError("No creatorUserId or recipients or recipient count is less than two returned by checkRecipientsAndSender() method.")
		getUsersForUserIds(recipients, null, func(users as DynamicVector) {
			assert users && users.getSize() > 1:
				logError("No recipients or recipient count is less than two returned by getUsersForUserIds() method.")
			foreach user as ChatUser in users.toVector() {
				assert user:
					logError("Invalid recipient with userId: '" .. user.getUserId() .. "'. Stopping broadcast message.")
				if not user.isOnline() {
					logDebug("User: '" .. user.getUserId() .. "' is offline with last active on: " .. String.forLongInteger(user.getLastActive()) .. ". Sending notification instead.")
					if message.getMessageType() == ChatMessage.DATA_TYPE:
						notifyUserForNewDataMessage(user, message)
					continue
				}
				var brokenConnections = new vector<string>
				foreach connectionId as string in user.getConnectionIds() {
					var connection = user.getConnection(connectionId)
					if not connection {
						brokenConnections += connectionId
						continue
					}
					var r = connection.sendMessage(message)
					if r < 1:
						brokenConnections += connectionId
				}
				foreach connectionId as string in brokenConnections:
					user.removeConnectionForId(connectionId)
				if not user.isOnline() {
					logDebug("User: '" .. user.getUserId() .. "' is offline with last active on: " .. String.forLongInteger(user.getLastActive()) .. ". Sending notification instead.")
					if message.getMessageType() == ChatMessage.DATA_TYPE:
						notifyUserForNewDataMessage(user, message)
					continue
				}
			}
		})
	})
}

func getUsersForUserIds(userIds as DynamicVector, users as DynamicVector, callback as function<void, DynamicVector>) private
{
	if not userIds || userIds.getSize() < 1 {
		callback(users)
		return
	}
	var userId = userIds.get(0) as string
	assert String.isNotEmpty(userId):
		callback(users)
	userIds.remove(0)
	getUser(userId, func(user as ChatUser) {
		assert user:
			callback(users)
		var list = users
		if not list:
			list = new DynamicVector()
		list.append(user)
		getUsersForUserIds(userIds, list, callback)
	})
}
