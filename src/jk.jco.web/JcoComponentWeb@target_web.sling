
/*
 * This file is part of Eqela Jkop
 * Copyright (c) 2021-2023 J42 Pte Ltd
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import jk.jco.common

class abstract is JcoComponent is !"HTMLElement":

prop children:childrenValue as vector<object>
{
	get {
		if not childrenValue:
			childrenValue = new vector<object>
		return childrenValue
	}
}

var shadow as dynamic
var styles as vector
var updateScheduled = false

ctor
{
}

func addToChildren(child as object)
{
	children += child
	update()
}

func removeChildren
{
	childrenValue = null
	update()
}

func replaceChildren(newChildren as vector<object>)
{
	childrenValue = null
	foreach child in newChildren:
		children += child
	update()
}

func updateStyle
{
	if styles {
		styles = null
		update()
	}
}

func updateContent:
	update()

func applyStyleSheet(styleSheet as JcoStyleSheet) virtual as bool
{
	var v = false
	if styleSheet {
		var nrules = new vector<JcoStyleSheet.Rule>
		foreach rule in styleSheet.rules {
			var selectors = rule.selectors
			if Vector.getSize(selectors) == 1 && Vector.get(selectors, 0) == "component" {
				foreach property in rule.properties {
					var key = property.key
					if key {
						var ov = getStyleProperty(key)
						if ov != property.value {
							setStyleProperty(key, property.value)
							v = true
						}
					}
				}
			}
			else {
				nrules += rule
			}
		}
		styleSheet.rules = nrules
	}
	return v
}

func getStyleSheetString virtual as string
{
	var v as string
	var ss = createStyleSheet()
	if ss {
		var n = 0
		loop {
			if applyStyleSheet(ss) {
				ss = createStyleSheet()
			}
			else {
				break
			}
			n ++
			if n > 10 {
				println "Un-ending style sheet creation loop. Aborting."
				break
			}
		}
		v = styleSheetToString(ss)
	}
	return v
}

func processStyleSheetString(value as string) virtual as string:
	return value

func getExternalStyleSheetString virtual as string:
	return getExternalStyleSheet()

func connectedCallback private
{
	// This is a standard Javascript callback, called by the web component framework
	onMounted()
}

func disconnectedCallback private
{
	// This is a standard Javascript callback, called by the web component framework.
	onUnmounted()
}

func ruleToString(rule as JcoStyleSheet.Rule) as string
{
	var sb = new StringBuilder()
	var first = true
	foreach selector in rule.selectors {
		if not first:
			sb.appendString(", ")
		sb.appendString(selector)
		first = false
	}
	sb.appendString(" {\n")
	foreach property in rule.properties {
		sb.appendString(property.key)
		sb.appendString(": ")
		sb.appendString(property.value)
		sb.appendString(";\n")
	}
	sb.appendString("}")
	return sb.toString()
}

func styleSheetToString(styleSheet as JcoStyleSheet) as string
{
	var sb = new StringBuilder()
	foreach rule in styleSheet.rules {
		var rstr = ruleToString(rule)
		if String.isNotEmpty(rstr) {
			sb.appendString(rstr)
			sb.appendCharacter('\n')
		}
	}
	return sb.toString()
}

func createElementByType(typename as typeinfo) as object
{
	var name = CustomElementManager.getRegisteredTypeName(typename)
	if String.isEmpty(name):
		Error.throw("failedToRegisterElementType", typename)
	return createElementByName(name)
}

func createElementByName(name as string) as object
{
	if String.isEmpty(name):
		Error.throw("emptyElementName", name)
	return lang "js" object {{{ document.createElement(name) }}}
}

func setElementAttribute(element as object, key as string, value as dynamic)
{
	assert element
	assert key
	if value == null {
		lang "js" {{{
			element.removeAttribute(key);
		}}}
	}
	else {
		lang "js" {{{
			element.setAttribute(key, value);
		}}}
	}
}

func addChild(parent as object, child as object)
{
	if child is vector {
		foreach realChild as object in child as! vector:
			addChild(parent, realChild)
		return
	}
	if parent is JcoComponent {
		(parent as! JcoComponent).addToChildren(child)
	}
	else if parent is vector {
		(parent as! vector) += child
	}
	else {
		lang "js" {{{
			parent.append(child)
		}}}
	}
}

func update
{
	if not updateScheduled {
		updateScheduled = true
		lang "js" {{{
			setTimeout(function() {
				this.executeUpdate();
			}.bind(this), 0)
		}}}
	}
}

func executeUpdate
{
	updateScheduled = false
	var shadowRoot = this.shadow
	if not styles {
		var nstyles = new vector
		var ss = processStyleSheetString(getStyleSheetString())
		if ss {
			var styleDOM = lang "js" object {{{ document.createElement("style") }}}
			lang "js" {{{
				styleDOM.textContent = ss;
			}}}
			nstyles += styleDOM
		}
		var ess = getExternalStyleSheetString()
		if ess {
			var es = lang "js" object {{{ document.createElement("link") }}}
			lang "js" {{{
				es.setAttribute("rel", "stylesheet");
				es.setAttribute("href", ess);
			}}}
			nstyles += es
		}
		lang "js" {{{
			shadowRoot.replaceChildren(...nstyles)
		}}}
		styles = nstyles
	}
	else {
		var rms = new vector
		var max = lang "js" int {{{ shadowRoot.childNodes.length }}}
		for(var n=0; n<max; n++) {
			var o = lang "js" object {{{ shadowRoot.childNodes[n] }}}
			var isStyle = false
			foreach sto in styles {
				if o == sto {
					isStyle = true
					break
				}
			}
			if not isStyle:
				rms += o
		}
		foreach rm in rms {
			lang "js" {{{
				shadowRoot.removeChild(rm)
			}}}
		}
	}
	var cc = render()
	if cc {
		foreach cco in cc:
			shadowRoot.appendChild(cco)
	}
	onRendered()
}

func onCreated virtual
{
	shadow = lang "js" dynamic {{{ this.attachShadow({ mode: 'open' }) }}}
}

func onMounted virtual:
	nop

func onRendered virtual:
	nop

func onUnmounted virtual:
	nop

func createStyleSheet virtual as JcoStyleSheet:
	return new JcoStyleSheet()

func getExternalStyleSheet virtual as string:
	return null

func setStyleProperty(name as string, value as string) virtual:
	println "WARNING: Unprocessed style property `" .. name .. "'"

func getStyleProperty(name as string) virtual as string:
	return null

func render abstract as vector
