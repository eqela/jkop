
/*
 * This file is part of Jkop
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class is SQLiteDatabase:

import cave
import cape
depend "objc-header-m:<sqlite3.h>"
depend "ldlib:sqlite3"
depend "ldlib:z"

var db as !"sqlite3*"

class Statement is SQLStatement
{
	var paramidx as int
	var sql as string #used
	var compiledStmt as !"sqlite3_stmt*"
	var err as string
	var strings as vector<string>
	var isStoredProcedure = false

	func setIsStoredProcedure(v as bool) as SQLStatement
	{
		isStoredProcedure = v
		return this
	}

	func getIsStoredProcedure as bool:
		return isStoredProcedure

	ctor:
		strings = new vector<string>

	dtor:
		clear()

	func create(db as !"sqlite3", ss as string) as bool
	{
		var b as bool
		var r as int #used
		var compiledStatement as !"sqlite3_stmt*"
		paramidx = 1
		lang "objc" {{{
			if (sqlite3_prepare_v2(db, [ss UTF8String], -1, &compiledStatement, NULL) == SQLITE_OK) {
				b = YES;
				sql = ss;
				compiledStmt = compiledStatement;
			}
			else {
				const char *errMsg;
				b = NO;
				errMsg = sqlite3_errmsg(db);
				err = [NSString stringWithUTF8String:errMsg];
			}
		}}}
		return b
	}

	func addParamString(val as string) as SQLStatement
	{
		var v = -1
		if compiledStmt {
			var p = compiledStmt
			var pi = paramidx
			var valString #used = val
			lang "objc" {{{
				if (sqlite3_bind_text((sqlite3_stmt*)p, pi, [valString UTF8String], -1, SQLITE_STATIC) == SQLITE_OK) {
					v = pi;
					pi++;
				}
			}}}
			paramidx = pi
		}
		if v > 0:
			strings += val
		return this
	}

	func addParamInteger(val as int) as SQLStatement
	{
		var v #used = -1
		if compiledStmt {
			var p = compiledStmt
			var pi = paramidx
			var valInt #used = val
			lang "objc" {{{
				if (sqlite3_bind_int((sqlite3_stmt**)p, pi, valInt) == SQLITE_OK) {
					v = pi;
					pi ++;
				}
			}}}
			paramidx = pi
		}
		return this
	}

	func addParamLongInteger(val as long) as SQLStatement
	{
		return addParamInteger(val as int)
	}

	func addParamDouble(val as double) as SQLStatement
	{
		var v #used = -1
		if compiledStmt {
			var p = compiledStmt
			var pi = paramidx
			var valDouble #used = val
			lang "objc" {{{
				if (sqlite3_bind_double(p, pi, valDouble) == SQLITE_OK) {
					v = pi;
					pi ++;
				}
			}}}
			paramidx = pi
		}
		return this
	}

	func addParamBlob(val as buffer) as SQLStatement
	{
		var v #used = -1
		if compiledStmt {
			var p = compiledStmt
			var pi = paramidx
			var s #used = Buffer.getSize(val)
			var valBuffer #used = val
			lang "objc" {{{
				if (sqlite3_bind_blob(p, pi, (__bridge void *)(valBuffer), s, SQLITE_TRANSIENT) == SQLITE_OK) {
					v = pi;
					pi ++;
				}
			}}}
			paramidx = pi
		}
		return this
	}

	func setParamString(name as string, val as string) as SQLStatement:
		return addParamString(val)

	func setParamInteger(name as string, val as int) as SQLStatement:
		return addParamInteger(val)

	func setParamLongInteger(name as string, val as long) as SQLStatement:
		return addParamLongInteger(val)

	func setParamDouble(name as string, val as double) as SQLStatement:
		return addParamDouble(val)

	func setParamBlob(name as string, val as buffer) as SQLStatement:
		return addParamBlob(val)

	func resetStatement
	{
		assert compiledStmt
		lang "objc" {{{
			sqlite3_clear_bindings(compiledStmt);
			sqlite3_reset(compiledStmt);
		}}}
	}

	func getError as string:
		return err

	func execute as bool
	{
		assert compiledStmt
		var b as bool
		lang "objc" {{{
			if (sqlite3_step(compiledStmt) == SQLITE_DONE) {
				b = YES;
			}
			else {
				b = NO;
			}
		}}}
		return b
	}

	func clear
	{
		var p = compiledStmt
		lang "objc" {{{
			if (p !=(void*)0) {
				sqlite3_finalize((sqlite3_stmt**)p);
			}
		}}}
		compiledStmt = null
		strings = new vector<string>
	}

	func getCompiledStmt as !"sqlite3_stmt*":
		return compiledStmt
}

class ResultSet is SQLResultSetIterator
{
	var compiledStmt as !"sqlite3_stmt*"
	var columnNames as vector<string>

	func create(stmt as Statement) static as this
	{
		var v = new this()
		v.compiledStmt = stmt.getCompiledStmt()
		return v
	}

	func next override as DynamicMap
	{
		assert compiledStmt
		var n as DynamicMap
		var columnNames as vector<string>
		if step() {
			n = new DynamicMap()
			columnNames = getColumnNames()
			var cnCount = Vector.getSize(columnNames)
			for(var i = 0; i < cnCount; i++) {
				var s = getColumnObject(i)
				var cn = Vector.get(columnNames, i)
				n.set(cn, s)
			}
		}
		return n
	}

	func nextValues(values as vector<object>) override as bool
	{
		assert values
		assert compiledStmt
		if not step():
			return false
		Vector.clear(values)
		var cols = getColumnCount()
		for(var i = 0; i < cols; i++) {
			var s as string
			lang "objc" {{{
				char *ss = sqlite3_column_text(compiledStmt, i);
				if (ss != NULL) {
					s = [NSString stringWithUTF8String:ss];
				}
			}}}
			values += s
		}
		return true
	}

	func step override as bool
	{
		var b as bool
		lang "objc" {{{
			if (sqlite3_step(compiledStmt) == SQLITE_ROW) {
				b = YES;
			}
			else {
				b = NO;
			}
		}}}
		return b
	}

	func getColumnCount override as int
	{
		assert compiledStmt
		var count as int
		lang "objc" {{{
			count = sqlite3_column_count(compiledStmt);
		}}}
		return count
	}

	func getColumnName(n as int) override as string
	{
		var name as string
		assert compiledStmt
		lang "objc" {{{
			char *nn = (char *)sqlite3_column_name(compiledStmt, n);
			if (nn != NULL) {
				name = [NSString stringWithUTF8String:nn];
			}
		}}}
		return name
	}

	func getColumnNames override as vector<string>
	{
		if not columnNames {
			columnNames = new vector<string>
			for(var i = 0 ; i < getColumnCount() ; i++) {
				var cn = getColumnName(i)
				if cn == null:
					cn = ""
				columnNames += cn
			}
		}
		return columnNames
	}

	func getColumnObject(n as int) override as object
	{
		assert compiledStmt
		var type as int
		var p = compiledStmt
		lang "objc" {{{
			type = sqlite3_column_type(p, n);
		}}}
		if type == 1:
			return Integer.asObject(getColumnInt(n))
		if type == 2:
			return Double.asObject(getColumnDouble(n))
		if type == 3 {
			var s as string
			lang "objc" {{{
				char* ss = (char*)sqlite3_column_text(compiledStmt, n);
				if (ss != NULL) {
					s = [NSString stringWithUTF8String:ss];
				}
			}}}
			return s
		}
		if type == 4:
			return Buffer.asObject(getColumnBuffer(n))
		return ""
	}

	func getColumnInt(n as int) override as int
	{
		assert compiledStmt
		var v as int
		lang "objc" {{{
			v = sqlite3_column_int(compiledStmt, n);
		}}}
		return v
	}

	func getColumnDouble(n as int) override as double
	{
		assert compiledStmt
		var v as double
		lang "objc" {{{
			v = sqlite3_column_double(compiledStmt, n);
		}}}
		return v
	}

	func getColumnBuffer(n as int) override as buffer
	{
		assert compiledStmt
		var v as buffer
		lang "objc" {{{
			void *data = (void *)sqlite3_column_blob(compiledStmt, n);
			if (data != NULL) {
				v = (__bridge NSMutableData *)(data);
			}
		}}}
		return v
	}

	func close override
	{
		compiledStmt = null
	}
}

func initialize(file as File, create as bool) override as bool
{
	assert file
	if create == false && file.isFile() == false {
		Log.error(getLogger(), "Database does not exist: " .. file.getPath())
		return false
	}
	var nativePath = assert file.getPath():
		Log.error(getLogger(), "Database file '" .. file.getPath() .. "' is not on a native filesystem. Cannot open.")
	var v = false
	var error as string = null
	var dbp as !"sqlite3*"
	lang "objc" {{{
		if (sqlite3_open([nativePath UTF8String], &dbp) == SQLITE_OK) {
			v = true;
		}
		else {
			v = false;
		}
	}}}
	this.db = dbp
	if v {
		Log.debug(getLogger(), "Opened Sqlite database: " .. file.getPath())
	}
	else {
		Log.error(getLogger(), "Failed to open database file: " .. error)
	}
	return v
}

func close override
{
	assert this.db
	var dbp as !"sqlite3*"
	dbp = this.db
	lang "objc" {{{
		sqlite3_close(dbp);
	}}}
	this.db = null
}

func prepare(sql as string) override as SQLStatement
{
	assert sql
	var v = new Statement()
	assert v.create(this.db, sql)
	return v
}

func execute(stmt as SQLStatement) override as bool
{
	assert stmt
	var ss = stmt as Statement
	var b as bool
	b = ss.execute()
	return b
}

func executeUpdateDelete(stmt as SQLStatement) override as int
{
	var v = 0
	if execute(stmt) {
		var dbp as !"sqlite3*"
		dbp = this.db
		lang "objc" {{{
			v = sqlite3_changes(dbp);
		}}}
	}
	return v
}

func query(stmt as SQLStatement) override as SQLResultSetIterator
{
	var v as SQLResultSetIterator
	assert stmt
	var ss = stmt as Statement
	v = ResultSet.create(ss)
	return v
}

func close(callback as function) override
{
	close()
	if callback:
		callback()
}

func execute(stmt as SQLStatement, callback as function<void, bool>) override
{
	var v = execute(stmt)
	if callback:
		callback(v)
}

func executeUpdateDelete(stmt as SQLStatement, callback as function<void, int>) override
{
	var v = executeUpdateDelete(stmt)
	if callback:
		callback(v)
}

func query(stmt as SQLStatement, callback as function<void, SQLResultSetIterator>) override
{
	var v = query(stmt)
	if callback:
		callback(v)
}

func querySingleRow(stmt as SQLStatement, callback as function<void, DynamicMap>) override
{
	var v = querySingleRow(stmt)
	if callback:
		callback(v)
}

func tableExists(table as string, callback as function<void, bool>) override
{
	var v = tableExists(table)
	if callback:
		callback(v)
}
